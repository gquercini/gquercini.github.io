---
title: "Elastic Search"
heading: Gestion et analyse des donn√©es ‚Äî Tutoriel 8
linktitle: gad-elastic-fr
output:
  bookdown::pdf_book:
    toc: false
    includes:
      in_header: ./latex-files/preamble.tex
    number_sections: yes
  blogdown::html_page:
    number_sections: no
  html_document:
    df_print: paged

menu:
  gadfr:
    parent: tutoriels
    identifier: gad-elastic-fr
    name: 8. Elastic Search
    weight: 8

params:
  solution: true
summary: Introduction √† Elastic Search.
draft: no
type: docs

---

<link rel="stylesheet" href="/styles/course.css">
<link rel="stylesheet" href="/styles/cloud-computing.css">


L'objectif de ce tutoriel est de se familiariser avec Elastic Search, un moteur de recherche et d'analyse distribu√© bas√© sur Lucene. 


# Pr√©paration de l'environnement

La premi√®re chose √† faire est de **d√©marrer Elastic Search** via la proc√©dure suivante :

* Ouvrez une fen√™tre de *PowerShell*.

* D√©placez-vous dans le r√©pertoire `elasticsearch-9.2.1`  via la commande suivante :

```
cd Desktop\elasticsearch-9.2.1
``` 

* Lancez Elastic Search avec la commande suivante :

```
bin\elasticsearch.bat
```

* Attendez environ 30 secondes : le serveur va d√©marrer et il restera bloqu√© sur cette fen√™tre.

* Ouvrez une page du navigateur web et saisissez l'adresse suivante : `http://localhost:9200`.

* Vous devriez obtenir une r√©ponse JSON o√π l'attribut *tagline* vaut *You Know, for Search*. Si la r√©ponse n'appara√Æt pas, attendez encore quelques secondes et rafra√Æchissez la page.


Ensuite, nous allons **d√©marrer Kibana**, l'interface web d'Elastic Search qui nous permettra, entre autres, d'ex√©cuter des requ√™tes et visualiser les r√©sultats.

* Ouvrez un nouvel onglet dans le PowerShell, **sans fermer** celui o√π Elastic Search est en cours d'ex√©cution.

* D√©placez-vous dans le r√©pertoire `kibana-9.2.1`  via la commande suivante :

```
cd Desktop\kibana-9.2.1
```

* Lancez Kibana avec la commande suivante :

```
bin\kibana.bat
```

* Attendez **5-6 minutes** pour que Kibana d√©marre compl√®tement.

* Ouvrez une page du navigateur web et saisissez l'adresse suivante : `http://localhost:5601`.

* Dans la page d'accueil de Kibana, cliquez sur *Explore on my own*.

* Cliquez sur ‚ò∞ dans le menu en haut √† gauche.

* S√©lectionnez *Management*  et *Dev tools*.

* Une console appara√Æt o√π nous pourrons saisir des requ√™tes Elastic Search.

* Essayez la requ√™te suivante dans la console et cliquez sur le bouton ‚ñ∂Ô∏è pour l'ex√©cuter :

```
GET /
```

* Vous devriez obtenir une r√©ponse JSON similaire √† celle obtenue pr√©c√©demment dans le navigateur web.


# Terminolgie 

* **Document** : unit√© de donn√©es de base dans Elastic Search. Un document est repr√©sent√© en JSON et contient un ensemble de champs (attributs) et de valeurs. 
  C'est l'√©quivalent d'une ligne dans une base de donn√©es relationnelle ou d'un document dans MongoDB.
  
* **Index** : collection de documents qui partagent des propri√©t√©s similaires. C'est l'√©quivalent d'une table dans une base de donn√©es relationnelle ou d'une collection dans MongoDB.

* **Mapping** : le processus de d√©finition de la mani√®re dont un document, et les champs qu'il contient, sont stock√©s et index√©s. En d'autres termes, c'est le sch√©ma d'un index
    (un peu comme le sch√©ma d'une table dans une base de donn√©es relationnelle).


# V√©rification d'Elastic Search


Nous allons v√©rifier l'etant de sant√© du cluster via la commande suivante :

```
GET _cluster/health 
```

Vous devriez obtenir une r√©ponse JSON o√π l'attribut *status* vaut *green* ; il y a d√©j√† 36 shards actifs. 
Pourquoi ? 
Parce qu'Elastic Search cr√©e automatiquement des indices de syst√®me pour son propre fonctionnement interne.
V√©rifions-le avec la commande suivante :

```
GET /_cat/indices?expand_wildcards=all&v
```

Vous devriez voir une liste de 36 indices ; comme nous travaillons sur un cluster compos√© d'un seul n≈ìud, il y a un seul shard primaire pour chaque indice et aucun shard r√©pliqu√©.


# Mapping

Lorsqu'on cr√©e un index, Elastic Search g√©n√®re automatiquement un mapping bas√© sur les donn√©es des documents index√©s. 
C'est ce qu'on appelle le **dynamic mapping**.
Le dynamic mapping utilise des r√®gles heuristiques pour d√©terminer le type de donn√©es de chaque champ (texte, nombre, date, etc.) et les propri√©t√©s associ√©es (analyseur, indexation, etc.).
Bien que le dynamic mapping soit pratique pour des cas simples et rapides, et qu'il fonctionne bien dans de nombreux sc√©narios, il n'est pas toujours optimal.
Par exemple, lorsqu'on souhaite indexer des dates, Elastic Search peut ne pas les reconna√Ætre correctement si elles ne sont pas dans un format standard ISO.

En r√®gle g√©n√©rale, il est recommand√© de **d√©finir explicitement le mapping** lors de la cr√©ation d'un index.

La commande suivante cr√©e un index nomm√© ``employees``, avec un mapping explicite :

```json
PUT employees
{
  "mappings": {
    "properties": {
      "name":{ "type": "text"},
      "age": {"type": "integer"},
      "email": {"type": "keyword"},
      "address":{
        "properties": {
          "street":{ "type":"text" },
          "country":{ "type":"text" }
        }
      }
    }
  },
  "settings": {
    "number_of_replicas" : 0
  }
}
```


::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


```{exercise}

Ex√©cutez la commande ci-dessus dans la console de Kibana pour cr√©er l'index ``employees`` avec le mapping sp√©cifi√©.
Observez la d√©finition du mapping et expliquez le choix des types de donn√©es pour chaque champ.


```

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

Le champ \x60\x60name\x60\x60 est de type \x60\x60text\x60\x60 car il peut contenir des phrases ou des mots, et on souhaite effectuer des recherches en texte int√©gral.
Le champ \x60\x60age\x60\x60 est de type \x60\x60integer\x60\x60 car il repr√©sente un nombre entier.
Le champ \x60\x60email\x60\x60 est de type \x60\x60keyword\x60\x60 car il s'agit d'une valeur unique qui ne n√©cessite pas d'analyse en texte int√©gral.
Le champ \x60\x60address\x60\x60 est un objet imbriqu√© contenant deux sous-champs : \x60\x60street\x60\x60 et \x60\x60country\x60\x60, 
tous deux de type \x60\x60text\x60\x60 car ils peuvent contenir des phrases ou des mots.

A noter que le nombre de r√©plicas est d√©fini √† 0 dans les param√®tres de l'index, car nous travaillons sur un cluster √† n≈ìud unique.
Par d√©faut, Elastic Search cr√©e un r√©plica pour chaque shard primaire, mais si sur un noeud cela entra√Æne le passage de l'√©tat du cluster √† jaune,
car les r√©plicas ne peuvent pas √™tre allou√©s sur le m√™me n≈ìud que les shards primaires.

Le message de confirmation de la cr√©ation de l'index devrait ressembler √† ceci :
\x60\x60\x60json
{
  \"acknowledged\": true,
  \"shards_acknowledged\": true,
  \"index\": \"employees\"
}
\x60\x60\x60

Le premier message indique que la requ√™te a √©t√© accept√©e, le deuxi√®me que tous les shards primaires ont √©t√© allou√©s avec succ√®s,
et le troisi√®me donne le nom de l'index cr√©√©.

:::
</details>
"}`

## Mettre √† jour le mapping

Il est possible de mettre √† jour le mapping d'un index existant en utilisant la commande ``PUT`` avec le chemin ``_mapping``.

Ex√©cutez la commande suivante dans la console de Kibana pour ajouter deux nouveaux champs au mapping de l'index ``employees`` : ``joining_date`` (de type ``date``) et ``phone_number`` (de type ``keyword``).

```json
PUT employees/_mapping
{
  "properties":{
    "joining_date":{
      "type":"date",
      "format":"dd-MM-yyyy"
    },
    "phone_number":{
      "type":"keyword"
    }
  }
}
```

Remarquez que pour le champ ``joining_date``, nous avons sp√©cifi√© un format de date personnalis√© (jour-mois-ann√©e) pour correspondre au format des dates que nous allons indexer par la suite.

::: {.infobox .warning data-latex="{warning}"}
**Modifications des champs existants**


Il n'est **pas possible** de modifier le type ou les propri√©t√©s d'un champ existant dans le mapping.
La raison en est que cela entra√Ænerait des erreurs lorsqu'on cherche les donn√©es d√©j√† index√©es car ils ne correspondraient plus au nouveau mapping.
Si on souhaite modifier le type ou les propri√©t√©s d'un champ existant, il faut cr√©er un nouvel index avec le mapping mis √† jour,
puis r√©indexer les documents de l'ancien index vers le nouveau en utilisant l'API de r√©indexation d'Elastic Search.

:::



## Le type de donn√©es ``text``

Afin de g√©rer les recherches en texte int√©gral, Elastic Search propose le type de donn√©es ``text``.
Avant de stocker un champ de type ``text``, Elastic Search applique un processus appel√© **analyse**.
L'analyse est appliqu√©e par un objet appel√© **analyseur** (ang., *analyzer*) ; selon l'analyseur utilis√©, le texte est transform√© en une suite de **tokens** et ensuite 
stock√© dans un format interne optimis√© pour la recherche.

Pour chaque champ de type ``text``, Elastic Search utilise par d√©faut l'analyseur **standard**.



::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Ex√©cutez la commande suivante :


    POST _analyze
    {
        "text": "The movie was sick!!! Hilarious :) :) and WITTY ;) a KiLLer üëç"
    }

Pourriez expliquer les √©tapes de l'analyse effectu√©e par l'analyseur standard ?

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

L'analyseur standard effectue les √©tapes suivantes :

* Les caract√®res de ponctuation et les caract√®res sp√©ciaux sont supprim√©s.

* Le texte est divis√© en tokens en utilisant les espaces comme s√©parateurs.

* Les tokens sont convertis en minuscules.



:::
</details>
"}`

Nous pouvons √©galement changer l'analyseur par d√©faut pour un champ de type ``text``.

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Ex√©cutez la commande suivante pour analyser le m√™me texte en utilisant l'analyseur ``english`` : 

    POST _analyze
    {
        "text": "The movie was sick!!! Hilarious :) :) and WITTY ;) a KiLLer üëç",
        "analyzer": "english"
    }
    
Pourriez expliquer les diff√©rences entre les tokens produits par l'analyseur ``standard`` et ceux produits par l'analyseur ``english`` ?


````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

M√™mes √©tapes que l'analyseur standard, mais en plus :
* Les mots vides (ang., *stop words*) sont supprim√©s. Par exemple, les mots \"the\", \"was\", \"and\", \"a\" sont supprim√©s.

* Les tokens sont r√©duits √† leur racine (ang., *stem*). Par exemple, les tokens \"hilarious\", \"witty\" et \"movie\" sont r√©duits √† leurs racines \"hilari\", \"witti\" et \"movi\".


:::
</details>
"}`

D'autres analyseurs sont disponibles dans Elastic Search, adapt√©s √† diff√©rentes langues et besoins : 

* **standard** : analyseur par d√©faut, adapt√© pour l'anglais et d'autres langues.

* **simple** : divise le texte en tokens en utilisant des caract√®res non alphab√©tiques comme s√©parateurs, et convertit les tokens en minuscules.

* **whitespace** : divise le texte en tokens en utilisant uniquement les espaces comme s√©parateurs, sans convertir en minuscules.

* **stop** : similaire √† l'analyseur simple, mais supprime √©galement les mots vides (ang., *stop words*). Fonctionne pour l'anglais.

* **keyword** : ne divise pas le texte en tokens, mais le traite comme un seul token. Utile pour les champs qui ne n√©cessitent pas d'analyse en texte int√©gral, comme les identifiants ou les codes postaux.

* **language-specific analyzers** : analyseurs sp√©cifiques pour diff√©rentes langues, comme ``french``, ``german``, ``spanish``, etc., qui incluent des r√®gles de traitement sp√©cifiques √† chaque langue.

* **pattern** : permet de d√©finir des expressions reguli√®res pour diviser le texte en tokens.

* **custom analyzers** : permet de cr√©er des analyseurs personnalis√©s en combinant diff√©rents composants, comme des tokenizers, des filtres de tokens et des filtres de caract√®res.

# Documents

Elastic Search permet de manipuler des documents via les APIs suivantes :

* **Document Indexing API** : pour indexer (c'est √† dire, ajouter √† un index) des documents.

* **Read and Search API** : pour r√©cup√©rer et rechercher des documents.

* **Update API** : pour mettre √† jour des documents existants.

* **Delete API** : pour supprimer des documents.

Ces APIs peuvent √™tre utilis√©es pour manipuler des documents individuellement (*single-document API*) ou en masse (*multi-document API*).

## Indexer des documents

Chaque document a un identifiant unique (ID) qui permet de le retrouver dans l'index.
C'est √©quivalent √† la cl√© primaire dans une base de donn√©es relationnelle.
Les identifiants peuvent √™tre sp√©cifi√©s manuellement lors de l'indexation d'un document, ou g√©n√©r√©s automatiquement par Elastic Search si aucun identifiant n'est fourni.

* Pour indexer un document avec un identifiant sp√©cifi√©, on utilise la commande ``PUT`` avec le chemin suivant : ``/{index}/_doc/{id}``.

* Pour indexer un document sans sp√©cifier d'identifiant, on utilise la commande ``POST`` avec le chemin suivant : ``/{index}/_doc/``.

Cr√©ons un index d'abord. 


::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Cr√©ez un index nomm√© ``movies`` avec les champs suivants :

* ``title`` (de type ``text``);

* ``release_year`` (de type ``date`` avec le format ``yyyy``);

* ``synopsis`` (de type ``text``).


````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

\x60\x60\x60
PUT movies
    {
      \"settings\": {
        \"number_of_replicas\" : 0
      },
      \"mappings\": {
        \"properties\": {
          \"title\": { \"type\": \"text\" },
          \"release_year\": { \"type\": \"date\", \"format\": \"yyyy\" },
          \"synopsis\": { \"type\": \"text\" }
        }
      }
    }
\x60\x60\x60

:::
</details>
"}`


Vous pouvez maintenant indexer des documents dans l'index ``movies``.

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Ajoutez un nouveau document (avec identifiant 1) dans l'index ``movies`` pour le film **The Godfather 1** avec les champs suivants :

* ``title`` : ``The Godfather 1``
* ``release_year`` : ``1972``
* ``synopsis`` : ``The aging patriarch of an organized crime dynasty transfers control of his clandestine empire to his reluctant son.``

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

\x60\x60\x60
PUT movies/_doc/1
{
  \"title\": \"The Godfather 1\",
  \"release_year\": \"1972\",
  \"synopsis\": \"The aging patriarch of an organized crime dynasty transfers control of his clandestine empire to his reluctant son.\"
}
\x60\x60\x60

:::
</details>
"}`


::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Observez la r√©ponse JSON retourn√©e par Elastic Search apr√®s l'indexation du document.
Copiez-la dans un fichier texte.
R√©-ex√©cutez la m√™me commande pour indexer le m√™me document (avec le m√™me identifiant 1) mais en modifiant le synopsis.
Observez la nouvelle r√©ponse JSON et comparez-la avec la pr√©c√©dente.
Quelles diff√©rences remarquez-vous ?

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

* Le \x60\x60result\x60 dans la r√©ponse JSON change de \x60\x60created\x60 √† \x60\x60updated\x60.

* Le \x60\x60_version\x60 dans la r√©ponse JSON est incr√©ment√© de 1.

* Le \x60\x60sequence number\x60 dans la r√©ponse JSON est incr√©ment√© de 1.

:::
</details>
"}`

Nous pouvons √©galement indexer des documents sans sp√©cifier d'identifiant (en utilisant POST).
La commande suivante :

```json
POST movies/_doc/
{
  "title": "The Godfather 2",
  "release_year": "1974",
  "synopsis": "The early life and career of Vito Corleone in 1920s New York City is portrayed while his son, Michael, expands and tightens his grip on his crime syndicate."
}
```

cr√©era un nouveau document avec un identifiant g√©n√©r√© automatiquement par Elastic Search. Nous pourrons retrouver cet identifiant dans la r√©ponse JSON retourn√©e apr√®s l'indexation du document.

::: {.infobox .warning data-latex="{warning}"}
**Bonne pratique**


Il n'est **pas conseill√©** de m√©langer des documents avec des ID manuellement sp√©cifi√©s et des documents avec des ID g√©n√©r√©s automatiquement dans le m√™me index.

:::

## R√©cup√©rer des documents

Pour r√©cup√©rer un document par son identifiant, on utilise la commande ``GET`` avec le chemin suivant : ``/{index}/_doc/{id}``.

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Utilisez la commande GET pour r√©cup√©rer le document avec l'identifiant 1 dans l'index ``movies``.
Analysez la r√©ponse JSON retourn√©e par Elastic Search.

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

\x60\x60\x60
GET movies/_doc/1
\x60\x60\x60

Dans la r√©ponse JSON, on retrouve deux sections principales : les m√©tadonn√©es du document et le contenu du document lui-m√™me.
Dans les m√©tadonn√©es, on trouve des informations telles que l'index, le type de document, l'identifiant, la version, etc.

Pour ne retourner que le contenu du document, on peut acc√©der √† l'attribut \x60\x60_source\x60\x60 dans la r√©ponse JSON.

\x60\x60\x60
GET movies/_source/1
\x60\x60\x60

Si nous voulons r√©cup√©rer seulement les m√©tadonn√©es du document sans le contenu, nous pouvons utiliser la commande suivante :

\x60\x60\x60
GET movies/_doc/1?_source=false
\x60\x60\x60


:::
</details>
"}`

Dans l'exercice pr√©c√©dent, nous avons r√©cup√©r√© tous les champs du document.
Il est possible de r√©cup√©rer seulement certains champs sp√©cifiques en utilisant le param√®tre ``?_source_includes`` dans la commande ``GET``.

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**

````{exercise}

Utilisez la commande GET pour r√©cup√©rer seulement le champ ``title`` du document avec l'identifiant 1 dans l'index ``movies``.

````
:::
`r if(params$solution) {"
<details>
<summary>Solution</summary>
::: {.infobox .exosolution data-latex=\"{exercisebox}\"}
\x60\x60\x60
GET movies/_doc/1?_source_includes=title
\x60\x60\x60
:::
</details>
"}`


::: {.infobox .warning data-latex="{warning}"}
**Exclusions des champs**

Il existe aussi le param√®tre ``?_source_excludes`` qui permet d'exclure certains champs sp√©cifiques lors de la r√©cup√©ration d'un document.

:::

## Mettre √† jour des documents

La mise √† jour d'un document existant est effectu√©e via les √©tapes suivantes :

* Elastic Search r√©cup√®re le document existant.

* Applique les modifications sp√©cifi√©es dans la requ√™te de mise √† jour.

* R√©indexe le document mis √† jour.

Lorsqu'on met √† jour un document, Elastic Search incr√©mente la version du document ; l'ancienne version du document n'est pas conserv√©e.

### Ajouter un champ √† un document

La commande suivante ajoute deux nouveaux champs ``director`` et ``actors`` au document avec l'identifiant 1 dans l'index ``movies`` :

```json
POST movies/_update/1
{
  "doc": {
    "actors":["Marlon Brando","Al Pacino","James Caan"],
    "director":"Francis Ford Coppola"  
  }
}
```

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Ex√©cutez la commande ci-dessus. 
Est-ce que la commande r√©ussit m√™me si les champs ``director`` et ``actors`` n'existent pas encore dans le mapping de l'index ``movies`` ?


````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

La commande r√©ussit car Elastic Search utilise le dynamic mapping pour ajouter automatiquement les nouveaux champs au mapping de l'index.
On peut v√©rifier cela en r√©cup√©rant le mapping de l'index \x60\x60movies\x60\x60 apr√®s la mise √† jour du document.

\x60\x60\x60
GET movies/_mapping
\x60\x60\x60

:::
</details>
"}`

### Modification des champs existants

Pour mettre √† jour un champ existant dans un document, on sp√©cifie simplement la nouvelle valeur du champ dans la requ√™te de mise √† jour.

```json
POST movies/_update/1
{
  "doc": {
    "title":"The Godfather 1 (Original)"
  }
}
```

Lorsqu'il faut ajouter un √©l√©ment √† un tableau dans un document, il faut sp√©cifier les nouvelles et les anciennes valeurs du tableau.
La commande suivante ajoute un nouvel acteur au tableau ``actors`` dans le document avec l'identifiant 1 dans l'index ``movies`` :

```json
POST movies/_update/1
{   
  "doc": {
    "actors":["Marlon Brando","Al Pacino","James Caan","Robert Duvall"]
  }
}
```

On peut √©viter de sp√©cifier les anciennes valeurs du tableau en utilisant une mise √† jour par script :

```json
POST movies/_update/1
{
  "script": {
   "source": "ctx._source.actors.add('Diane Keaton')"
  }
}
```

De mani√®re similaire, on peut supprimer un √©l√©ment d'un tableau en utilisant une mise √† jour par script :

```json
POST movies/_update/1
{
 "script":{
   "source":
     "ctx._source.actors.remove(ctx._source.actors.indexOf('Diane Keaton'))"
  }
}
```

Nous pouvons √©galement utiliser des scripts pour ajouter un champ :

```json
POST movies/_update/1
{
  "script": {
    "source": "ctx._source.imdb_user_rating = 9.2"
  }
}
```

ou bien pour supprimer un champ :

```json
POST movies/_update/1
{
  "script": {
    "source": "ctx._source.remove('imdb_user_rating')"
  }
}
```

Nous pouvons aussi ajouter plusieurs champs en une seule mise √† jour par script :

```json
POST movies/_update/1
{
  "script": {
    "source": """
    ctx._source.runtime_in_minutes = 175;
    ctx._source.metacritic_rating= 100;
    ctx._source.tomatometer = 97;
    ctx._source.boxoffice_gross_in_millions = 134.8;
    """
  }
}
```

Et enfin, nous pouvons aussi faire des mises √† jour conditionnelles en utilisant des scripts.

```json
POST movies/_update/1
{
  "script": {
    "source": """
    if(ctx._source.boxoffice_gross_in_millions > 125) 
      {ctx._source.blockbuster = true} 
     else 
      {ctx._source.blockbuster = false}
    """
  }
}
```

### Mise √† jour via des requ√™tes

Dans les exemples pr√©c√©dents, nous avons mis √† jour des documents en sp√©cifiant leur identifiant.
Il est aussi possible de mettre √† jour des documents en utilisant des requ√™tes pour s√©lectionner les documents √† mettre √† jour.
Lorsque nous avons ajout√© le film **The Godfather 2**, un nouvel identifiant a √©t√© g√©n√©r√© automatiquement par Elastic Search.
Supposons que nous ne connaissons pas cet identifiant, mais que nous voulons ajouter des acteurs au film **The Godfather 2**.

Nous pouvons utiliser la commande suivante :

```json
POST /movies/_update_by_query
{
  "script": {
    "source": """
      if (ctx._source.actors == null) {
        ctx._source.actors = [];
      }
      for (actor in params.new_actors) {
        if (!ctx._source.actors.contains(actor)) {
          ctx._source.actors.add(actor);
        }
      }
    """,
    "params": {
      "new_actors": ["Al Pacino", "Robert De Niro", "Diane Keaton"]
    }
  },
  "query": {
    "match": {
      "title": "The Godfather 2"
    }
  }
}
```

::: {.infobox .warning data-latex="{warning}"}
**Langage de scripting**

Elastic Search utilise **Painless** comme langage de scripting par d√©faut pour les mises √† jour par script.
D'autres langages de scripting peuvent √™tre utilis√©s, comme par exemple **expression**, **mustache** ou **java**.


:::

## Supprimer des documents

La suppression d'un document est effectu√©e en utilisant la commande ``DELETE`` avec le chemin suivant : ``/{index}/_doc/{id}``.
On peut aussi supprimer des documents en utilisant des requ√™tes pour s√©lectionner les documents √† supprimer via la commande ``DELETE`` avec le chemin suivant : ``/{index}/_delete_by_query``.

```json
POST movies/_delete_by_query
{
  "query":{
    "match":{
      "director":"Francis Ford Coppola"
    }
  }
}
```

Si nous voulons supprimer les films o√π Al Pacino est un des acteurs, nous pouvons utiliser la commande suivante :

```json
POST movies/_delete_by_query
{
  "query":{
    "match":{
      "actors":"Al Pacino"
    }
  }
}
```

# Rechercher des documents

ElasticSearch permet de faire des recherches **structur√©es** et **non structur√©es** via l'API de recherche.

Les premi√®res renvoient des r√©sultats qui ne sont pas associ√©s √† un score de pertinence.
ElasticSearch renvoie des documents qui correspondent exactement aux crit√®res de la requ√™te.
Cela est similaire aux requ√™tes SQL dans les bases de donn√©es relationnelles.
Ces types de requ√™tes sont appel√©es **term-level queries**.

Les secondes renvoient des r√©sultats associ√©s √† un score de pertinence.
ElasticSearch renvoie des documents qui sont similaires √† la requ√™te. 
Ces requ√™tes sont appel√©es **full-text queries**.

## Term-level queries

Elastic Search fournit plusieurs types de term-level queries, parmi lesquelles : **term query**, **terms query**, **range query**, **exists query** ...
Nous allons voir quelques exemples.

### Term query

Une term query recherche des documents qui contiennent un terme exact dans un champ sp√©cifique.

```json
GET /movies/_search
{
  "query": {
    "term": {
      "year": 1972
    }
  }
}
```

Lorsqu'on fait une term query, la valeur recherch√©e n'est pas analys√©e, mais elle est recherch√©e telle quelle dans l'index.
Par cons√©quent, les term queries sont g√©n√©ralement utilis√©es pour les champs de type ``keyword``, ``integer``, ``date``, etc., mais pas pour les champs de type ``text``.
Regardons ce qui se passe si nous faisons une term query sur le champ ``title``, qui est de type ``text`` :

```json
GET /movies/_search
{
  "query": {
    "term": {
      "title": "The Godfather"
    }
  }
}
```

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Pourquoi cette requ√™te ne retourne-t-elle aucun document, m√™me si nous avons index√© un film dont le titre exact est "The Godfather" ?


````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

La requ√™te ne retourne aucun document car le champ \x60\x60title\x60\x60 est de type \x60\x60text\x60\x60, et donc le texte a √©t√© analys√© avant d'√™tre index√©.
L'analyseur standard a divis√© le titre en tokens : \x60\x60the\x60\x60 et \x60\x60godfather\x60\x60, et les a convertis en minuscules.
Par cons√©quent, il n'y a pas de terme exact \x60\x60The Godfather\x60\x60 dans l'index.

:::
</details>
"}`

### Terms query

Une terms query recherche des documents qui contiennent au moins un des termes sp√©cifi√©s dans un champ sp√©cifique.

```json
GET /movies/_search
{
  "query": {
    "terms": {
      "year": [1972, 1974]
    }
  }
}
```

### Exists query

La exists query recherche des documents qui contiennent un champ sp√©cifique, quel que soit sa valeur.

```json
GET /movies/_search
{
  "query": {
    "exists": {
      "field": "director"
    }
  }
}
```

### Range query

Une range query recherche des documents dont la valeur d'un champ sp√©cifique se situe dans une plage donn√©e.

```json
GET /movies/_search
{
  "query": {
    "range": {
      "year": {
        "gte": 1970,
        "lte": 2010
      }
    }
  }
}
```

Nous pouvons mieux apr√©cier le r√©sultat de la range query en ajoutant un tri sur le champ ``release_year`` :

```json
GET /movies/_search
{
  "query": {
    "range": {
      "year": {
        "gte": 1970,
        "lte": 2010
      }
    }
  },
  "sort": [
    {
      "year": { "order": "asc" }
    }
  ]
}
```

### Wildcard query

Une wildcard query recherche des documents qui correspondent √† un motif sp√©cifi√© dans un champ sp√©cifique.
Par exemple, pour rechercher des titres de films qui commencent par "g" et se terminent par "er", nous utilisons la commande suivante :
```json
GET /movies/_search
{
  "query": {
    "wildcard": {
      "title": "g*er"
    }
  }
}
```

Remarquez que nous avons utilis√© des lettres minuscules dans le motif, car le champ ``title`` est de type ``text`` et a √©t√© analys√© en minuscules avant d'√™tre index√©.

Les types de wildcards disponibles sont :
* ``?`` : correspond √† un seul caract√®re.
* ``*`` : correspond √† z√©ro ou plusieurs caract√®res.

### Prefix queries

Les prefix queries recherchent des documents dont la valeur d'un champ sp√©cifique commence par un pr√©fixe donn√©.

Par exemple, pour recherche des films o√π un des acteurs commence par "Al", nous utilisons la commande suivante :

```json
GET /movies/_search
{
  "query": {
    "prefix": {
      "actors": "al"
    }
  }
}
```

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Pourquoi la commande ci-dessus retourne des films o√π Tim Allen est un des acteurs, alors que son nom ne commence pas par "Al" ?

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

Le champ \x60\x60actors\x60\x60 est de type \x60\x60text\x60\x60, et donc les noms des acteurs ont √©t√© analys√©s avant d'√™tre index√©s.
L'analyseur standard a divis√© les noms en tokens et les a convertis en minuscules.
Ainsi, le nom \x60\x60Tim Allen\x60\x60 a √©t√© divis√© en deux tokens : \x60\x60tim\x60\x60 et \x60\x60allen\x60\x60.
Le token \x60\x60allen\x60\x60 commence par \x60\x60al\x60\x60, donc le film est retourn√© dans les r√©sultats de la requ√™te.


:::
</details>
"}`

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Pourriez-vous exprimer la m√™me requ√™te en utilisant une wildcard query au lieu d'une prefix query ?

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

\x60\x60\x60
GET /movies/_search
{
  \"query\": {
    \"wildcard\": {
      \"actors\": \"al*\"
    }
  }
}
\x60\x60\x60

:::
</details>
"}`

### Fuzzy query

Les fuzzy queries recherchent des documents qui correspondent approximativement √† une valeur donn√©e dans un champ sp√©cifique.
Elles sont utiles pour g√©rer les fautes de frappe ou les variations orthographiques.
La recherche est bas√©e sur la distance de Levenshtein, qui mesure le nombre de modifications n√©cessaires pour transformer une cha√Æne de caract√®res en une autre.
Par exemple, le terme "roam" peut √™tre transform√© en "foam" avec une seule modification (remplacer 'r' par 'f'), donc la distance de Levenshtein est 1.

La commande suivante recherche des titres de films qui sont similaires √† "godfater" avec une distance maximale de 1 :

```json
GET /movies/_search
{
  "query": {
    "fuzzy": {
      "title": {
        "value": "godfater",
        "fuzziness": 1
      }
    }
  }
}
```

Il n'est pas g√©n√©ralement possible de pr√©dire combien de fautes de frappe seront pr√©sentes dans une requ√™te de recherche.
Par cons√©quent, Elastic Search permet d'utiliser le param√®tre ``AUTO`` pour la fuzziness, qui ajuste automatiquement la distance maximale en fonction de la longueur du terme recherch√©.
Les valeurs utilis√©es sont les suivantes :
* 0 pour les termes de longueur 1 ou 2. Pour des mots tr√®s courts, l'utilisateur est cens√© taper correctement le mot.
* 1 pour les termes de longueur 3, 4 ou 5.
* 2 pour les termes de longueur sup√©rieure √† 5.

Un exemple d'utilisation de ``AUTO`` pour la fuzziness est le suivant :

```json
GET /movies/_search
{
  "query": {
    "fuzzy": {
      "title": {
        "value": "godfater",
        "fuzziness": "AUTO"
      }
    }
  }
}
```

## Full-text queries









 
On va maintenant voir des exemples de recherches. 

D'abord, supprimez l'index ``movies``:

```json
DELETE movies
```


::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}


* T√©l√©chargez le fichier que vous trouverez 
<a href="/courses/databases/gadexed/tutorial-8/movies.json" download="movies.json">√† ce lien</a>
qui contient des documents √† indexer dans un index nomm√© `movies`.

* Ouvrez un nouvel onglet dans PowerShell, d√©placez-vous dans le r√©pertoire o√π vous avez t√©l√©charg√© le fichier et ex√©cutez la commande suivante pour indexer les documents dans l'index `movies` :

        curl.exe -XPOST "http://localhost:9200/_bulk" -H "Content-Type: application/x-ndjson" --data-binary "@movies.json"

* Dans la console de Kibana, ex√©cutez la commande suivante pour v√©rifier que les documents ont √©t√© index√©s correctement :

        GET /movies/_count

* Vou devriez obtenir 53 documents.

````

:::

::: {.infobox .warning data-latex="{warning}"}
**√âtat du cluster**

Si vous ex√©cutez la commande :

```
GET _cluster/health
```

vous verrez que l'√©tat du cluster est *yellow*. Cela est d√ª au fait que l'index `movies` a √©t√© automatiquement cr√©√© avec le nombre par d√©faut de r√©plicas (1).
:::


Elastic Search fournit l'endpoint ``_search`` pour effectuer des recherches dans un index.

Pour chercher tous les films dont le titre contient le mot "Godfather", nous utilisons la commande suivante :

```json
GET /movies/_search
{
  "query": {
    "match": {
      "title": "Godfather"
    }
  }
}
```

::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Observez le resultat retourn√© par Elastic Search.

* Combien de documents ont √©t√© trouv√©s ?

* Comment sont-ils ordonn√©s dans le r√©sultat ?

* Pourquoi le premier document a un score plus √©lev√© que les autres ?


````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

* 2 documents ont √©t√© trouv√©s.

* Ils sont ordonn√©s par score de pertinence d√©croissant (du plus pertinent au moins pertinent).

* Le premier document a un score plus √©lev√© car le mot Godfather appara√Æt dans un ttitre plus court (The Godfather) que dans le deuxi√®me document (The Godfather Part II).

:::
</details>
"}`

## Expliquer le score

Si nous voulons comprendre comment le score de pertinence est calcul√©, nous pouvons utiliser un drapeau sp√©cial appel√© ``explain`` dans notre requ√™te de recherche.

```json
GET /movies/_search
{
   "explain": true, 
  "_source": false, 
  "query": {
    "match": {
      "title": "Godfather"
    }
  }
}
```

Vous devriez pouvoir identifier les diff√©rentes composantes du score de pertinence dans la r√©ponse JSON retourn√©e par Elastic Search 
(le term frequency, le inverse document frequency...).

## Requ√™tes compos√©es 

Elastic Search permet de combiner plusieurs crit√®res de recherche en utilisant des requ√™tes bool√©ennes via l'op√©rateur ``bool``.

Les clauses bool√©ennes disponibles sont :

* **must** : les documents doivent correspondre √† tous les crit√®res sp√©cifi√©s dans cette clause (c'est l'op√©rateur logique AND).

* **should** : les documents doivent correspondre √† au moins un des crit√®res sp√©cifi√©s dans cette clause (c'est l'op√©rateur logique OR).

* **must_not** : les documents ne doivent pas correspondre aux crit√®res sp√©cifi√©s dans cette clause (c'est l'op√©rateur logique NOT).

* **filter** : les documents doivent correspondre aux crit√®res sp√©cifi√©s dans cette clause (comme pour **must**), mais ces crit√®res n'affectent pas le score de pertinence.


::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

Que fait la requ√™te suivante ?
    
    GET movies/_search
    {
      "query": {
        "bool": {
          "must": [
            {
              "match": {
                "title": "Godfather"
              }
            },
            {
              "range": {
                "year": {
                  "gte": 1970,
                  "lte": 1972
                }
              }
            }
          ]
        }
      }
    }



````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

Elle recherche les films dont le titre contient le mot \"Godfather\" **et** dont l'ann√©e de sortie est comprise entre 1970 et 1972 (inclus).

:::
</details>
"}`


::: {.infobox .exercisebox data-latex="{exercisebox}"}
**Exercice**


````{exercise}

√âcrivez une requ√™te qui recherche les films dont le titre contient le mot "Godfather" **ou** "Pulp Fiction", mais **pas** "Part II".

````

:::

`r if(params$solution) {"
<details>
<summary>Solution</summary>

::: {.infobox .exosolution data-latex=\"{exercisebox}\"}

\x60\x60\x60
GET /movies/_search
{
  \"query\": {
    \"bool\": {
      \"should\": [
        {
          \"match\": {
            \"title\": \"Godfather\"
          }
        },
        {
          \"match\": {
            \"title\": \"Pulp Fiction\"
          }
        }
      ],
      \"must_not\": {
        \"match\": {
          \"title\": \"Part II\"
        }
      }
    }
  }
}
\x60\x60\x60

:::
</details>
"}`

La requ√™te suivante utilise la clause ``filter`` pour rechercher les films dont le titre contient le mot "Godfather".



```json
GET /movies/_search
{
  "query": {
    "bool": {
      "filter": {
        "match": {
          "title": "Godfather"
        }
      }
    }
  }
}
```

Ces requ√™tes sont plus rapides car Elastic Search n'a pas besoin de calculer les scores de pertinence.



## Pagination 

Les requ√™tes peuvent retourner un grand nombre de documents, dans l'ordre de plusieurs milliers.
Il ne serait pas efficace de retourner tous ces documents en une seule requ√™te, car aussi bien le serveur que le client ne pourraient pas disposer de suffisamment de 
m√©moire pour traiter un si grand volume de donn√©es.

Par d√©faut, Elastic Search retourne seulement les 10 premiers documents correspondant √† une requ√™te, mais nous pouvons contr√¥ler 
le nombre de documents retourn√©s en utilisant le param√®tre ``size``.

```json
GET movies/_search
{
  "size": 20, 
  "query": {
    "match_all": {}
  }
}
```

On peut aussi utiliser le param√®tre ``from`` pour sp√©cifier l'offset (le nombre de documents √† ignorer avant de commencer √† retourner les r√©sultats).
La requ√™te suivante retourne 2 documents, en ignorant les 5 premiers documents correspondant √† la requ√™te.

```json
GET movies/_search
{
  "from": 5,
  "size": 2,
  "query": {
    "match_all": {}
  }
}
```

## S√©lection des champs retourn√©s

Par d√©faut, Elastic Search retourne tous les champs des documents correspondant √† une requ√™te.
Nous avons vu pr√©c√©demment que nous pouvons contr√¥ler les champs retourn√©s en utilisant les param√®tres ``_source_includes`` et ``_source_excludes``.
Une autre mani√®re de s√©lectionner les champs retourn√©s est d'utiliser l'objet ``fields`` dans la requ√™te de recherche.
Notez que lorsque nous utilisons l'objet ``fields``, nous devons d√©sactiver le retour du champ ``_source`` en utilisant le param√®tre ``"_source": false``.

```json
GET /movies/_search
{
  "_source": false,
  "query": {
    "match": {
      "title": "Godfather"
    }
  },
  "fields": ["title", "year"]
}
```













# Bibliographie

Plusieurs exemples de ce tutoriel sont tir√©s du livre suivant :

Madhusudhan Konda, *Elasticsearch in Action*, Second Edition, Mnning Publications, 2023.





