<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8">
    <title>Document Model Exercises</title>
    <link rel="stylesheet" type="text/css" href="./styles/exercises.css">

    <link rel="stylesheet" href="./styles-hjs/default.css">
    <script src="./scripts/highlight.pack.js"></script>

    <script>hljs.initHighlightingOnLoad();</script>
    <script>
      function showHideSolution(elem, elemLink) {
        state = document.getElementById(elem).style.display;
        if (state == "none") {
        	document.getElementById(elem).style.display='block';
          document.getElementById(elemLink).innerHTML='Hide solution'
        }
        else {
          document.getElementById(elem).style.display='none';
          document.getElementById(elemLink).innerHTML='See solution'
        }

      }
    </script>
  </head>
  <body>

    <img src="./figs/cs-logo.png" alt="cs-logo" class="logo">

    <h1>Exercises on the Document Data Model</h1>

    <h2>Modeling the database of a driving school</h2>

    We want to design the database of a driving school in ÃŽle-de-France that has several branches across the region.
    The school needs to store personal data about each customer, as well as the branch where the customer is enrolled.

    <br>In order to get a driver's license, a customer must take an exam at any branch of the school.
    If s/he fails the exam, s/he can take the exam again any time after a week.
    If s/he passes the exam, s/he is given a driver license with a unique license number; the license is defined by a category (that
    limits the types of vehicles that the owner can drive) and has an expiry date.

    <h3> Questions </h3>

    <ol type="a">
      <li> Model the database for the driving school in MongoDB.
        [<a href="#" onclick="showHideSolution('driving-school-mongodb', 'driving-school-mongodb-link');return false;"><span id="driving-school-mongodb-link">See solution</span></a>].

      <div id="driving-school-mongodb" style="display:none;" class="reltables">
      There are many possible answers to this question and the ideal model depends on how the data is queried.
      It's therefore useful to propose a model that makes the queries below easier to write.
      We propose here one collection called <TT>customers</TT> that contain the documents that describe the customers.
      Each document that describes a customer has the following properties:
      <ul>
       <li> <i>first_name</i>, <i>last_name</i>, <i>phone_number</i>, <i>birth_date</i>.
      <li> <i>address</i>. The value of this property is itself a  document that has the following properties:
        <ul>
        <li> <i>street_number</i>, <i>street_name</i>, <i>department</i>, <i>city</i> and <i>postal_code</i>.
        </ul>
      <li> <i>enrolled_branch</i>. The value of this property is a document with the following properties:
      <ul>
        <li> <i>name</i>, <i>address</i> (the value is a document as explained before).
      </ul>
      <li> <i>licenses</i>. The value of this property is an array of documents, each with the following properties:
      <ul>
        <li> <i>license_number</i>, <i>category</i>, <i>expiry_date</i>, <i>branch</i> (the value of the last property is a document).
      </ul>
      <li> <i>exams</i>. The value of this property is an array of documents, each with the following properties:
        <ul>
          <li> <i>outcome</i>, <i>date_exam</i>, <i>branch</i> (the value of the last property is a document).
        </ul>
      </ul>
      All documents have a property <i>_id</i> whose value is generated by MongoDB and identifies a document.
      </div>

      <li>Write a query in MongoDB to get the first and the last name of all customers with a category B driver license
        [<a href="#" onclick="showHideSolution('driving-school-q1', 'driving-school-q1-link');return false;"><span id="driving-school-q1-link">See solution</span></a>].
        <div id="driving-school-q1" style="display:none;">
          <pre>
          <code>
db.customers.find({"licenses.category": "B"}, {first_name:1, last_name:1, _id:0})
          </code>
          </pre>
        </div>

        <li>Write a query in MongoDB to get the name of the branch that has the highest number of exam failures
          [<a href="#" onclick="showHideSolution('driving-school-q2', 'driving-school-q2-link');return false;"><span id="driving-school-q2-link">See solution</span></a>].
          <div id="driving-school-q2" style="display:none;">
            <pre>
            <code>
db.customers.aggregate({$unwind: "$exams"},
                       {$match:{"exams.outcome":"failure"}},
                       {$group: {_id: {"branch_name": "$exams.branch.name"}, nbFailures:{$sum:1}}},
                       {$sort: {nbFailures:-1}}, {$limit: 1} );
            </code>
            </pre>
            <div class="reltables">
              <b>WARNING.</b> Suppose that we call <TT>$match</TT> before <TT>$unwind</TT>.
              The condition of the <TT>$match</TT> retains all customers
              that have at least one exam with outcome "failure"; this includes customers that also have some exams with outcome "success".
              As a result, when we call <TT>$unwind</TT>, some of the documents that we get in return have an exam with outcome "success" as the value
              of the property <i>exams</i>; this means that when we group by <i>branch_name</i>, we end up counting the successes, besides the failures.
              <p>
                As opposed to that, by calling <TT>$unwind</TT> before, we deconstruct the array <i>exams</i> and then, with the operator <TT>$match</TT>,
                we only keep the exams that have outcome "failure".
             </p>
           </div>

          </div>

          <li>Write a query in MongoDB to rank the cities in descending order by the number of exam successes of their residents
            [<a href="#" onclick="showHideSolution('driving-school-q3', 'driving-school-q3-link');return false;"><span id="driving-school-q3-link">See solution</span></a>].
            <div id="driving-school-q3" style="display:none;">
              <pre>
              <code>
db.customers.aggregate( {$unwind: "$exams"},
                        {$match:{"exams.outcome":"success"}},
                        {$group: {_id: {"city": "$address.city", "postal_code":"$address.postal_code"}, nbSuccesses:{$sum:1}}},
                        {$sort: {nbSuccesses:-1}} );
              </code>
              </pre>

            </div>

            <li>Write a query in MongoDB to get the first name and surname of the customers who failed an exam more than once
              [<a href="#" onclick="showHideSolution('driving-school-q4', 'driving-school-q4-link');return false;"><span id="driving-school-q4-link">See solution</span></a>].
              <div id="driving-school-q4" style="display:none;">
                <pre>
                <code>
db.customers.aggregate( {$unwind: "$exams"}, {$match:{"exams.outcome":"failure"}},
                        {$group: {_id: {"customer_id": "$_id", "first_name":"$first_name", "last_name":"$last_name"}, nbFailures:{$sum:1}}},
                        {$match: {nbFailures: {$gte: 2}}} );
                </code>
                </pre>
                <div class="reltables">
                Note that the second <TT>$match</TT> imposes a condition on the number of failures that we computed in the <TT>$group$</TT> clause.
                </div>
              </div>

    </ol>

    <h2>Modeling the database of a social network platform</h2>

    A social network platform wants to design a MongoDB database
    to store information on its users.
    For each user, the platform keeps its nickcname, that uniquely identifies
    the user in the platform, first and family name,
    geographic location (city and country) and email address;
    the user can register as many email addresses as s/he wishes.
    Any user can share content on the platform; each post is characterized by its content,
    date, time and, when available, the geolocation (latitude, longitude).
    Optionally, users can tag one or more friends in their posts.
    <p>
    Two users are linked by a friendship relationship if both agree on befriending
    each other; a user can also follow another user without necessarily befriending her.
    For any type of relationship (friendship or follower), the platform registers
    the date when the relationship is established.
    </p>

    <h3> Questions </h3>

    <ol type="a">
      <li> Model the database for the social network platform in MongoDB.
        [<a href="#" onclick="showHideSolution('social-network-solution', 'social-network-solution-link');return false;"><span id="social-network-solution-link">See solution</span></a>].

      <div id="social-network-solution" style="display:none;" class="reltables">
      We propose here one collection <TT>user</TT>, containing documents that describe a user.
      Each document that describes a user has the following properties:
      <ul>
        <li> <i>nickname</i>, <i>first_name</i>, <i>last_name</i>, <i>city</i>, <i>country</i>.
        <li> <i>email_addresses</i>. The value of this property is an array of strings.
        <li> <i>related_to</i>. The value of this property is an array of documents. Each document describes a relation and has the following properties:
          <ul>
            <li> <i>nickname</i>, the nickname of the person to which a user is related.
            <li> <i>first_name</i>, the first name of the person to which a user is related.
            <li> <i>last_name</i>, the last name of the person to which a user is related.
            <li> <i>country</i>, the country of the person to which a user is related.
            <li ><i>type</i>, the type of the relationship (friend or follower).
            <li> <i>date</i>, the date on which the relationship is established.
          </ul>
        <li> <i>posts</i>. The value of this property is an array of documents. Each document describes a post and has the following properties:
          <ul>
            <li> <i>content</i>, <i>date</i>, <i>time</i>, <i>lat</i>, <i>long</i>.
            <li> <i>tags</i>. The value of this property is an array of documents. Each document contain minimal information on a tagged user, and has the following properties:
            <ul>
              <li> <i>nickname</i>, <i>first_name</i>, <i>last_name</i>.
            </ul>
          </ul>
      </ul>
      </div>
      <li> Write a query in MongoDB that for each user, gets the number of followers by country. Rank the countries by the number of followers in descending order
        [<a href="#" onclick="showHideSolution('social-network-q1', 'social-network-q1-link');return false;"><span id="social-network-q1-link">See solution</span></a>].
        <div id="social-network-q1" style="display:none;">
          <pre>
          <code>
db.users.aggregate({$unwind:"$related_to"},
                   {$match:{"related_to.type":"follower"}},
                   {$group: {_id: {nickname:"$nickname", country:"$related_to.country"}, nb_followers:{$sum:1}}},
                   {$sort: {"_id.nickname":1, nb_followers:-1}} );
            </code>
          </pre>
        </div>
      <li> Write a query in MongoDB that gets the first and family name of the users tagged by 'john_smith'
        [<a href="#" onclick="showHideSolution('social-network-q2', 'social-network-q2-link');return false;"><span id="social-network-q2-link">See solution</span></a>].
        <div id="social-network-q2" style="display:none;">
          <pre>
          <code>
db.users.distinct("posts.tags", {nickname:"john_smith"});
          </code>
          </pre>
          Alternatively:
          <pre>
<code>
db.users.aggregate({$match:{nickname:"john_smith"}},
                  {$unwind: "$posts"},
                  {$unwind:"$posts.tags"},
                  {$group:{_id:{nickname: "$posts.tags.nickname", first_name:"$posts.tags.first_name", last_name:"$posts.tags.last_name"}}});
</code>
          </pre>
        </div>
        <li> Write a MongoDB query to get the nickname, first and last name of the common friends of 'john_smith' and 'lara_hughes'
          [<a href="#" onclick="showHideSolution('social-network-q3', 'social-network-q3-link');return false;"><span id="social-network-q3-link">See solution</span></a>].
          <div id="social-network-q3" style="display:none;">
            <pre>
            <code>
db.users.aggregate({$match:{nickname:{$in:['lara_hughes', 'john_smith']}}},
                   {$unwind:"$related_to"},
                   {$match:{"related_to.type": "friend"}},
                   {$group : {_id: {"nickname":"$related_to.nickname", "first_name":"$related_to.first_name", last_name:"$related_to.last_name"}, count:{$sum:1}}},
                   {$match:{count: {$gte: 2}}},
                   {$project: {"_id.nickname":1, "_id.first_name":1, "_id.last_name":1}});
            </code>
            </pre>
        <li> Write a MongoDB query to rank the users by the number of their followers. The user with the most followers must appear at the top of the list
          [<a href="#" onclick="showHideSolution('social-network-q4', 'social-network-q4-link');return false;"><span id="social-network-q4-link">See solution</span></a>].
              <div id="social-network-q4" style="display:none;">
                <pre>
                <code>
  db.users.aggregate({$unwind:"$related_to"},
                     {$match:{"related_to.type":"follower"}},
                     {$group:{_id:{"nickname":"$nickname"}, nb_followers:{$sum : 1}}}, {$sort: {nb_followers:-1}});
                </code>
                </pre>
              </div>
    </ol>

    <h2>Modeling the database of the banking system</h2>

    The following figure shows the ER diagram modeling the database of a banking system.

    <img src="./figs/banking-system-er.png" alt="banking-system-er" class="body-image" style="width:70%;">

    Each bank is identified by a unique code and name, and has one or several branches.
    A branch is responsible of opening accounts and granting loans to customers.
    Each account is identified by a number (<i>acct_nbr</i>) and is either
    a checking or savings account (property <i>acct_type</i>).
    Each customer is identified by its social security number (<i>ssn</i>);
    a customer can be granted several loans and open as many accounts as s/he wishes.

    <h3>Questions</h3>
    <ol type="a">
    <li> Model this database in MongoDB
      [<a href="#" onclick="showHideSolution('banking-system-model', 'banking-system-model-link');return false;"><span id="banking-system-model-link">See solution</span></a>].
      <div id ="banking-system-model" style="display:none;" class="reltables">
      In this exercise, we'll see how to use two distinct collections in MongoDB.
      We propose a collection <TT>customers</TT>, where each document describes a customer and has the following properties:
      <ul>
      <li> <i>ssn</i>, <i>first_name</i>, <i>last_name</i>,
        <i>address</i> (for simplicity, the value of this property is a string; the queries below do not ask to play with the individual elements of an address), <i>telephone</i>.
      <li> <i>loans</i>, the value of this property is an array, where each element is a document describing a loan, with the following properties:
      <ul>
        <li> <i>loan_nbr</i>, <i>loan_type</i>, <i>amount</i>, <i>branch</i> (the value of this property is the identifier of a branch, referring a document in the collection <TT>branches</TT>).
      </ul>
      <li> <i>accounts</i> , the value of this property is an array, where each element is a document describing an account, with the following properties:
      <ul>
        <li> <i>acct_number</i>, <i>acct_type</i>, <i>balance</i>, <i>branch</i> (same as for loan).
      </ul>
      </ul>
      A second collection, named <TT>branches</TT>, contains documents describing the branches. Each document has the following properties:
      <ul>
        <li> <i>branch_id</i> (the value of this property is used in a document describing a customer to refer to a branch),
          <i>address</i> (a simple string), <i>bank</i>. The value of this last property is a document that describes a bank with the following properties:
        <ul>
          <li> <i>code_bank</i>, <i>name</i>, <i>address</i> (a simple string).
        </ul>
      </ul>
      </div>

      <li> Write a MongoDB query to get all the data (including the full address) on the customers that have a checking account
          with a negative balance
          [<a href="#" onclick="showHideSolution('banking-system-q1', 'banking-system-q1-link');return false;"><span id="banking-system-q1-link">See solution</span></a>].
          <div id="banking-system-q1" style="display:none;">
            <pre>
            <code>
  db.customers.find({"accounts.balance": {$lt: 0}, "accounts.acct_type":"checking"});
            </code>
            </pre>
          </div>

      <li> Write a MongoDB query to get the SSN of all customers that have no loan at the 'Bank of America'
          [<a href="#" onclick="showHideSolution('banking-system-q2', 'banking-system-q2-link');return false;"><span id="banking-system-q2-link">See solution</span></a>].
          <div id="banking-system-q2" style="display:none;">
          <pre>
          <code>
db.customers.aggregate( {$lookup:{from:"branches", localField:"loans.branch", foreignField:"branch_id", as:"branch"}},
                        {$match: {"branch.bank.name" :{$ne:"Bank of America"}}}, {$project:{"ssn":1}})
          </code>
          </pre>
        <div class="reltables">
        Here we have to get the customers that have no loan at 'Bank of America'.
        The document that describes the loan of a customer has a property <i>branch</i>, whose value is the identifier of a branch in the collection <TT>branches</TT>.
        In order to get the name of a bank, we need to link the property <i>loans.branch</i> to the property <i>branch_id</i> of a document in the collection <TT>branches</TT>.
        This is accomplished with the operator <TT>$lookup</TT>.
        This operator has four fields: <i>from</i> indicates the target collection (in this case <TT>branches</TT>), <i>localField</i> indicates the name of the
        source property (in this case <i>loans.branch</i>), <i>foreignField</i> indicates the name of the target property (in this case <i>branch_id</i>) and
        <i>as</i> is just an alias that we assign to the document that we obtain from the target collection by linking the local and the foreign field.
        In the subsequent <TT>$match</TT> condition, we can access the name of the bank through the document <i>branch</i> and
        impose that it is different (operator <i>$ne</i>) from 'Bank of America'.
        </div>
      </div>
      <li> Write a MongoDB query to get the name of the bank that has the most branches
        [<a href="#" onclick="showHideSolution('banking-system-q3', 'banking-system-q3-link');return false;"><span id="banking-system-q3-link">See solution</span></a>].
        <div id="banking-system-q3" style="display:none;">
          <pre>
          <code>
db.branches.aggregate({$group:{_id:{code:"$bank.code_bank", name:"$bank.name"}, nb_branches:{$sum : 1}}},
                      {$sort:{nb_branches:-1}}, {$limit : 1} );
          </code>
          </pre>
        </div>
      <li> Write a MongoDB query to get the SSN of all customers having an account in more than one bank
        [<a href="#" onclick="showHideSolution('banking-system-q4', 'banking-system-q4-link');return false;"><span id="banking-system-q4-link">See solution</span></a>].
        <div id="banking-system-q4" style="display:none;">
          <pre>
          <code>
db.customers.aggregate({$unwind:"$accounts"},
                       {$lookup:{from:"branches", localField:"accounts.branch", foreignField:"branch_id", as:"branch"}},
                       {$group:{_id:{ssn:"$ssn", bank:"$branch.bank.code"}}},
                       {$group:{_id:{ssn:"$_id.ssn"}, count:{$sum : 1} }},
                       {$match: {count: {$gte : 2}}});
          </code>
          </pre>
        </div>

  </body>
  </html>
