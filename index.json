[{"authors":["admin"],"categories":null,"content":"Assistant professor at CentraleSupélec's computer science department.\nMember of the LaHDAK team at the Laboratoire de Recherche en Informatique (LRI).\n","date":-62135596800,"expirydate":-62135596800,"kind":"taxonomy","lang":"en","lastmod":-62135596800,"objectID":"2525497d367e79493fd32b198b28f040","permalink":"/authors/admin/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/authors/admin/","section":"authors","summary":"Assistant professor at CentraleSupélec's computer science department.\nMember of the LaHDAK team at the Laboratoire de Recherche en Informatique (LRI).","tags":null,"title":"Gianluca Quercini","type":"authors"},{"authors":null,"categories":null,"content":" Overview Nowadays, the marketing strategies of most companies are based on the analysis of massive and heterogeneous data that need a considerable amount of computational power. Instead of purchasing new hardware and software infrastructures, companies often resort to the computational and storage power offered by cloud computing platforms over the Internet.\nThe objective of this course is to present the fundamental principles of distributed computing that are at the heart of cloud computing. The course will cover the principles of virtualization and containerization and the methods and tools used for distributed processing (MapReduce and Spark).\n Prerequisites The main prerequisite is the course Information systems and programming:\n Python programming.\n Basic networking notions.\n Basic data management notions.\n  Previous experience with working the command-line terminal and Linux is desired but not essential.\nA beginner introduction to Linux is available here.\n Teaching staff  Gianluca Quercini\n Francesca Bugiotti\n Marc-Antoine Weisser\n Idir Ait Sadoune\n   Required software  Docker. See the installation guide.   Course summary Introduction  Context and applications. Service models (SaaS, PaaS, IaaS). Architectural design. Public cloud platforms. Cloud economic model.  Virtualization  Virtualization principles. Containerization (Docker). Orchestrators (Docker Swarm and Kubernetes).  Cloud programming and software environments  Parallel computing, programming paradigms. Hadoop MapReduce. Apache Spark.    Exam The evaluation will be based on the grades of some lab assignments.\n ","date":-62135596800,"expirydate":-62135596800,"kind":"section","lang":"en","lastmod":-62135596800,"objectID":"75dd1899c72e9422ddc316aac1a7c70e","permalink":"/courses/cloud-computing/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/","section":"courses","summary":"Presentation of the course Distributed and Cloud Computing","tags":null,"title":"Cloud Computing","type":"docs"},{"authors":null,"categories":null,"content":" The following tutorials are proposed in this course:\nGetting started with Docker. In this tutorial, you’ll use the basic tools to play with Docker containers and images.  more information to come.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"8d8d608ddecd5b8c7acbced80b9b6ab0","permalink":"/courses/cloud-computing/cc-tutorials/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/cc-tutorials/","section":"courses","summary":"Presentation of the tutorials of the course.","tags":null,"title":"Tutorials","type":"docs"},{"authors":[],"categories":[],"content":"","date":1581344688,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1581344688,"objectID":"4e459ff727a9e6a0c795e8d8f3d69232","permalink":"/project/data-for-you/","publishdate":"2020-02-10T15:24:48+01:00","relpermalink":"/project/data-for-you/","section":"project","summary":"","tags":[],"title":"Data for You","type":"project"},{"authors":["Fatiha Saïs","Joana E. Gonzales Malaverri","Gianluca Quercini"],"categories":null,"content":"","date":1577836800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1577836800,"objectID":"24e4602ce4c2a42bac26f3019386ecbf","permalink":"/publication/sais-2020/","publishdate":"2020-04-08T14:26:24.211279Z","relpermalink":"/publication/sais-2020/","section":"publication","summary":"","tags":null,"title":"MOMENT: Temporal Meta-Fact Generation and Propagation in Knowledge Graphs","type":"publication"},{"authors":["Nacéra Bennacer Seghouani","Coriane Nana Jipmo","Gianluca Quercini"],"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"3685ef29403450add392048ea8b1e19d","permalink":"/publication/seghouani-2019/","publishdate":"2020-02-10T15:32:10.718712Z","relpermalink":"/publication/seghouani-2019/","section":"publication","summary":"","tags":null,"title":"Determining the interests of social media users: two approaches","type":"publication"},{"authors":["Suela Isaj","Nacéra Bennacer Seghouani","Gianluca Quercini"],"categories":null,"content":"","date":1546300800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1546300800,"objectID":"f0a2e1e20345b7ff2748dd0ff24c29fd","permalink":"/publication/isaj-2019/","publishdate":"2020-02-10T15:37:10.960652Z","relpermalink":"/publication/isaj-2019/","section":"publication","summary":"","tags":null,"title":"Profile Reconciliation Through Dynamic Activities Across Social Networks","type":"publication"},{"authors":["Nacéra Bennacer Seghouani","Francesca Bugiotti","Moditha Hewasinghage","Suela Isaj","Gianluca Quercini"],"categories":null,"content":"","date":1514764800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514764800,"objectID":"ed97c59bbeebf6f67506ea911cd4d01b","permalink":"/publication/seghouani-2018/","publishdate":"2020-02-10T15:32:10.719498Z","relpermalink":"/publication/seghouani-2018/","section":"publication","summary":"","tags":null,"title":"A frequent named entities-based approach for interpreting reputation in Twitter","type":"publication"},{"authors":["Nacéra Bennacer Seghouani","Francesca Bugiotti","Jorge Galicia","Mariana Patricio","Gianluca Quercini"],"categories":null,"content":"","date":1514764800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1514764800,"objectID":"9cdf7741acd87116627b5dd0bc25a27c","permalink":"/publication/seghouani-2018-a/","publishdate":"2020-02-10T15:33:43.343039Z","relpermalink":"/publication/seghouani-2018-a/","section":"publication","summary":"","tags":null,"title":"Élimination des liens inter-langues erronés dans Wikipédia","type":"publication"},{"authors":["Nacéra Bennacer","Francesca Bugiotti","Jorge Galicia","Mariana Patricio","Gianluca Quercini"],"categories":null,"content":"","date":1483228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483228800,"objectID":"edcf86d1dd80092db4864af2aa551e98","permalink":"/publication/bennacer-2017-a/","publishdate":"2020-02-10T15:32:10.723551Z","relpermalink":"/publication/bennacer-2017-a/","section":"publication","summary":"","tags":null,"title":"Eliminating Incorrect Cross-Language Links in Wikipedia","type":"publication"},{"authors":["Coriane Nana Jipmo","Gianluca Quercini","Nacéra Bennacer"],"categories":null,"content":"","date":1483228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483228800,"objectID":"048dafc42b622ff1cee4c115e5409243","permalink":"/publication/jipmo-2017/","publishdate":"2020-02-10T15:32:10.722099Z","relpermalink":"/publication/jipmo-2017/","section":"publication","summary":"","tags":null,"title":"Frisk: A multilingual approach to find twitteR InterestS via wiKipedia","type":"publication"},{"authors":["Nacéra Bennacer","Francesca Bugiotti","Moditha Hewasinghage","Suela Isaj","Gianluca Quercini"],"categories":null,"content":"","date":1483228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483228800,"objectID":"1e3d10b83c3c7b1807d422d7d251cca3","permalink":"/publication/bennacer-2017/","publishdate":"2020-02-10T15:32:10.7231Z","relpermalink":"/publication/bennacer-2017/","section":"publication","summary":"","tags":null,"title":"Interpreting reputation through frequent named entities in twitter","type":"publication"},{"authors":["Gianluca Quercini","Nacéra Bennacer","Mohammad Ghufran","Coriane Nana Jipmo"],"categories":null,"content":"","date":1483228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483228800,"objectID":"c02251b35ab73929914bbe9b772e5248","permalink":"/publication/quercini-2017/","publishdate":"2020-02-10T15:32:10.720054Z","relpermalink":"/publication/quercini-2017/","section":"publication","summary":"","tags":null,"title":"Liaison: reconciliation of individuals profiles across social networks","type":"publication"},{"authors":["Mohammad Ghufran","Nacéra Bennacer","Gianluca Quercini"],"categories":null,"content":"","date":1483228800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1483228800,"objectID":"c1928a9ee227111e1b27ba31fdbb6a86","permalink":"/publication/ghufran-2017/","publishdate":"2020-02-10T15:32:10.722652Z","relpermalink":"/publication/ghufran-2017/","section":"publication","summary":"","tags":null,"title":"Wikipedia-based extraction of key information from resumes","type":"publication"},{"authors":["Coriane Nana Jipmo","Gianluca Quercini","Nacéra Bennacer"],"categories":null,"content":"","date":1451606400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1451606400,"objectID":"49508dab832a1726fe7da77e8604a7f8","permalink":"/publication/jipmo-2016/","publishdate":"2020-02-10T15:32:10.724083Z","relpermalink":"/publication/jipmo-2016/","section":"publication","summary":"","tags":null,"title":"Catégorisation et Désambiguı̈sation des Intérêts des Individus dans le Web Social.","type":"publication"},{"authors":["Nacéra Bennacer","Mia Johnson Vioulès","Maximiliano Ariel López","Gianluca Quercini"],"categories":null,"content":"","date":1420070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1420070400,"objectID":"ce3927111f9fc9f8ef041600fa6e6126","permalink":"/publication/bennacer-2015/","publishdate":"2020-02-10T15:32:10.725565Z","relpermalink":"/publication/bennacer-2015/","section":"publication","summary":"","tags":null,"title":"A multilingual approach to discover cross-language links in Wikipedia","type":"publication"},{"authors":["Mohammad Ghufran","Gianluca Quercini","Nacéra Bennacer"],"categories":null,"content":"","date":1420070400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1420070400,"objectID":"482b66b1b2e201edf7dfa2685afa010a","permalink":"/publication/ghufran-2015/","publishdate":"2020-02-10T15:32:10.724645Z","relpermalink":"/publication/ghufran-2015/","section":"publication","summary":"","tags":null,"title":"Toponym disambiguation in online social network profiles","type":"publication"},{"authors":["Nacéra Bennacer","Coriane Nana Jipmo","Antonio Penta","Gianluca Quercini"],"categories":null,"content":"","date":1388534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388534400,"objectID":"2bce9aaaae3b0248796b29334c06054f","permalink":"/publication/bennacer-2014/","publishdate":"2020-02-10T15:32:10.726341Z","relpermalink":"/publication/bennacer-2014/","section":"publication","summary":"","tags":null,"title":"Matching user profiles across social networks","type":"publication"},{"authors":["Nacéra Bennacer","Coriane Nana Jipmo","Antonio Penta","Gianluca Quercini"],"categories":null,"content":"","date":1388534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388534400,"objectID":"ff35f567785c6703d81172b874c7531b","permalink":"/publication/bennacer-2014-a/","publishdate":"2020-02-10T15:32:10.727368Z","relpermalink":"/publication/bennacer-2014-a/","section":"publication","summary":"","tags":null,"title":"Réconciliation des profils dans les réseaux sociaux.","type":"publication"},{"authors":["Gianluca Quercini","Hanan Samet"],"categories":null,"content":"","date":1388534400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1388534400,"objectID":"41c8a22b08bd7e057a05ad86a744cac5","permalink":"/publication/quercini-2014/","publishdate":"2020-02-10T15:32:10.728416Z","relpermalink":"/publication/quercini-2014/","section":"publication","summary":"","tags":null,"title":"Uncovering the spatial relatedness in Wikipedia","type":"publication"},{"authors":["Gianluca Quercini","Chantal Reynaud"],"categories":null,"content":"","date":1356998400,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1356998400,"objectID":"9086beba183fe687c8f4c462cd3153ca","permalink":"/publication/quercini-2013/","publishdate":"2020-02-10T15:32:10.72918Z","relpermalink":"/publication/quercini-2013/","section":"publication","summary":"","tags":null,"title":"Entity discovery and annotation in tables","type":"publication"},{"authors":["Gianluca Quercini","Chantal Reynaud"],"categories":null,"content":"","date":1325376000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325376000,"objectID":"cc5f1500c80ecfe28e62ab5e9b608e81","permalink":"/publication/quercini-2012-a/","publishdate":"2020-02-10T15:32:10.737022Z","relpermalink":"/publication/quercini-2012-a/","section":"publication","summary":"","tags":null,"title":"Des données tabulaires à RDF: l’extraction de données de Google Fusion Tables","type":"publication"},{"authors":["Massimo Ancona","Betty Bronzini","Davide Conte","Gianluca Quercini"],"categories":null,"content":"","date":1325376000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325376000,"objectID":"62840715b27d999325c6799de42c8994","permalink":"/publication/ancona-2012/","publishdate":"2020-02-10T15:32:10.717657Z","relpermalink":"/publication/ancona-2012/","section":"publication","summary":"","tags":null,"title":"Developing Attention-Aware and Context-Aware User Interfaces on Handheld Devices","type":"publication"},{"authors":["Antonio Penta","Gianluca Quercini","Chantal Reynaud","Nigel Shadbolt"],"categories":null,"content":"","date":1325376000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325376000,"objectID":"fa3cbdff0934af7e1ad34c9d906d46b4","permalink":"/publication/penta-2012/","publishdate":"2020-02-10T15:32:10.72995Z","relpermalink":"/publication/penta-2012/","section":"publication","summary":"","tags":null,"title":"Discovering Cross-language Links in Wikipedia through Semantic Relatedness.","type":"publication"},{"authors":["Gianluca Quercini","Jochen Setz","Daniel Sonntag","Chantal Reynaud"],"categories":null,"content":"","date":1325376000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325376000,"objectID":"1eb03ccdfc068b0af2eee6b98febab4f","permalink":"/publication/quercini-2012/","publishdate":"2020-02-10T15:32:10.736267Z","relpermalink":"/publication/quercini-2012/","section":"publication","summary":"","tags":null,"title":"Facetted Browsing on Extracted Fusion Tables Data for Digital Cities.","type":"publication"},{"authors":["Jochen Setz","Gianluca Quercini","Daniel Sonntag","Chantal Reynaud"],"categories":null,"content":"","date":1325376000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1325376000,"objectID":"152a779726400c4afb268da398df2025","permalink":"/publication/setz-2012/","publishdate":"2020-02-10T15:32:10.730492Z","relpermalink":"/publication/setz-2012/","section":"publication","summary":"","tags":null,"title":"Facetted search on extracted fusion tables data for digital cities","type":"publication"},{"authors":["Laura Papaleo","Gianluca Quercini","Viviana Mascardi","Massimo Ancona","A Traverso","Henry de Lumley"],"categories":null,"content":"","date":1293840000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1293840000,"objectID":"2951f449fe1a9a559bd320ee66d7a4df","permalink":"/publication/papaleo-2011/","publishdate":"2020-02-10T15:32:10.7311Z","relpermalink":"/publication/papaleo-2011/","section":"publication","summary":"","tags":null,"title":"Agents and Ontologies for Understanding and Preserving the Rock Art of Mount Bego.","type":"publication"},{"authors":["Gianluca Quercini","Massimo Ancona"],"categories":null,"content":"","date":1262304000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1262304000,"objectID":"712870e00c1980526965a476c61c6a9f","permalink":"/publication/quercini-2010/","publishdate":"2020-02-10T15:32:10.731853Z","relpermalink":"/publication/quercini-2010/","section":"publication","summary":"","tags":null,"title":"Confluent drawing algorithms using rectangular dualization","type":"publication"},{"authors":["Gianluca Quercini","Hanan Samet","Jagan Sankaranarayanan","Michael D Lieberman"],"categories":null,"content":"","date":1262304000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1262304000,"objectID":"c8ae118f82887db05d951390d2ae7695","permalink":"/publication/quercini-2010-a/","publishdate":"2020-02-10T15:33:43.347923Z","relpermalink":"/publication/quercini-2010-a/","section":"publication","summary":"","tags":null,"title":"Determining the spatial reader scopes of news sources using local lexicons","type":"publication"},{"authors":["Massimo Ancona","Viviana Mascardi","Gianluca Quercini","Anton Bogdanovych","H De Lumley","Laura Papaleo","Simeon Simoff","Antonella Traverso"],"categories":null,"content":"","date":1262304000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1262304000,"objectID":"6456e6f4265092c5466fcdd21d7bb4eb","permalink":"/publication/ancona-2010/","publishdate":"2020-02-10T15:32:10.73288Z","relpermalink":"/publication/ancona-2010/","section":"publication","summary":"","tags":null,"title":"Virtual institutions for preserving and simulating the culture of Mount Bego's ancient people","type":"publication"},{"authors":["Anton Bogdanovych","Laura Papaleo","Massimo Ancona","Viviana Mascardi","Gianluca Quercini","Simeon Simoff","Alex Cohen","Antonella Traverso"],"categories":null,"content":"","date":1230768000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1230768000,"objectID":"c71e7154cbc2dfbe25039ed19758c530","permalink":"/publication/bogdanovych-2009/","publishdate":"2020-02-10T15:32:10.737689Z","relpermalink":"/publication/bogdanovych-2009/","section":"publication","summary":"","tags":null,"title":"Integrating agents and virtual institutions for sharing cultural heritage on the Web","type":"publication"},{"authors":["Massimo Ancona","Gianluca Quercini"],"categories":null,"content":"","date":1230768000,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1230768000,"objectID":"e93eb6b5f5c5cf19230762a04c9abc05","permalink":"/publication/ancona-2009/","publishdate":"2020-02-10T15:32:10.720588Z","relpermalink":"/publication/ancona-2009/","section":"publication","summary":"","tags":null,"title":"Text Entry in PDAs with WtX","type":"publication"},{"authors":["Massimo Ancona","Davide Conte","Donatella Pian","Sonia Pini","Gianluca Quercini","Antonella Traverso"],"categories":null,"content":"","date":1199145600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1199145600,"objectID":"e650a879a57f2a6c286aa2d365cb9a7d","permalink":"/publication/ancona-2008/","publishdate":"2020-02-10T15:32:10.721064Z","relpermalink":"/publication/ancona-2008/","section":"publication","summary":"","tags":null,"title":"Wireless networks in archaeology and cultural heritage","type":"publication"},{"authors":["Massimo Ancona","Gianluca Quercini","Luca Dominici"],"categories":null,"content":"","date":1167609600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1167609600,"objectID":"5da2e1599d08bf6b66c9260251f7f87d","permalink":"/publication/ancona-2007-a/","publishdate":"2020-02-10T15:32:10.734718Z","relpermalink":"/publication/ancona-2007-a/","section":"publication","summary":"","tags":null,"title":"An Improved Text Entry Tool for PDAs","type":"publication"},{"authors":["M Ancona","S Drago","G Quercini","A Bogdanovych"],"categories":null,"content":"","date":1167609600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1167609600,"objectID":"0bb01482186a36901efd9bc59287ade5","permalink":"/publication/ancona-2007-b/","publishdate":"2020-02-10T15:33:43.342472Z","relpermalink":"/publication/ancona-2007-b/","section":"publication","summary":"","tags":null,"title":"Rectangular Dualization of Biconnected Planar Graphs in Linear Time and Related Applications","type":"publication"},{"authors":["M Ancona","S Drago","G Quercini","A Bogdanovych"],"categories":null,"content":"","date":1167609600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1167609600,"objectID":"5de935c6dca2f9dc45d3fcc539d7a23e","permalink":"/publication/ancona-2007/","publishdate":"2020-02-10T15:32:10.721486Z","relpermalink":"/publication/ancona-2007/","section":"publication","summary":"","tags":null,"title":"Rectangular Dualization of Biconnected Planar Graphs in Linear Time and Related Applications","type":"publication"},{"authors":["Massimo Ancona","Marco Cappello","Marco Casamassima","Walter Cazzola","Davide Conte","Massimiliano Pittore","Gianluca Quercini","Naomi Scagliola","Matteo Villa"],"categories":null,"content":"","date":1136073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1136073600,"objectID":"956e4fbb19a8e3db3caf66b9ca3ce215","permalink":"/publication/ancona-2006-a/","publishdate":"2020-02-10T15:33:43.349611Z","relpermalink":"/publication/ancona-2006-a/","section":"publication","summary":"","tags":null,"title":"Mobile vision and cultural heritage: the agamemnon project","type":"publication"},{"authors":["Massimo Ancona","Walter Cazzola","Sara Drago","Gianluca Quercini"],"categories":null,"content":"","date":1136073600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1136073600,"objectID":"152d79fb2becb0b67888c71837db1203","permalink":"/publication/ancona-2006/","publishdate":"2020-02-10T15:32:10.733963Z","relpermalink":"/publication/ancona-2006/","section":"publication","summary":"","tags":null,"title":"Visualizing and managing network topologies via rectangular dualization","type":"publication"},{"authors":["M Ancona","S Locati","M Mancini","A Romagnoli","G Quercini"],"categories":null,"content":"","date":1104537600,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":1104537600,"objectID":"a5f6251a4b15ec8ddae9685ad605d62a","permalink":"/publication/ancona-2005/","publishdate":"2020-02-10T15:32:10.735534Z","relpermalink":"/publication/ancona-2005/","section":"publication","summary":"","tags":null,"title":"Comfortable textual data entry for PocketPC: the WTX system","type":"publication"},{"authors":null,"categories":null,"content":" The evaluation will be based on the grades of some lab assignments.\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6036d72ede2a43e260416ac0bb62fe27","permalink":"/courses/cloud-computing/exam-presentation/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/exam-presentation/","section":"courses","summary":"Overview of the exam.","tags":null,"title":"Grading","type":"docs"},{"authors":null,"categories":null,"content":" under construction\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"f400dd4c32359ecd8a6381cfc5ebf258","permalink":"/courses/cloud-computing/cc-labs/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/cc-labs/","section":"courses","summary":"Presentation of the lab assignments of the course.","tags":null,"title":"Lab assignments","type":"docs"},{"authors":null,"categories":null,"content":" Under construction\n","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"68bd9207222bc65ba9bdedfe44865d2e","permalink":"/courses/cloud-computing/lectures/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/lectures/","section":"courses","summary":"Presenting the lectures.","tags":null,"title":"Lectures","type":"docs"},{"authors":null,"categories":null,"content":" Class material  Lecture slides, available here.\n An introduction to Docker.\n A Docker cheat sheet, with a summary of the most important Docker commands.\n An introduction to Linux, useful to understand how Docker works and how to interact with Docker.\n   Books  Schenker, Gabriel. Learn Docker - Fundamentals of Docker 18.x. Packt Publishing,. Print.\n Surianarayanan, C., \u0026amp; Chelliah, P. R. (2019). Essentials of Cloud Computing: A Holistic Perspective. Springer Nature.\n   ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"c8e4d3362d23c215703957c7ab60d73d","permalink":"/courses/cloud-computing/cc-references/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/cc-references/","section":"courses","summary":"Bibliographic references for the course","tags":null,"title":"References","type":"docs"},{"authors":null,"categories":null,"content":" Run containers Docker command: docker run [options] image-name [command] [arg]\nExample: Running a container from the image alpine.\n  docker run image-name   docker run image-name command   docker run image-name command arg     docker run alpine   docker run alpine ls   docker run alpine ping 192.168.3.1    Common options:\n  Remove the container when it exits   Give the container a name   Allocate a terminal for the container     docker run --rm alpine   docker run --name toto alpine   docker run -it alpine     Mount data-volume at /data**   Container port –\u0026gt; random host port   Host port 8080 –\u0026gt; container port 80     docker run -v data-volume:/data alpine   docker run --P alpine   docker run -p 8080:80 alpine     Attach container to network         docker run --network mynet alpine         Manage containers   List all containers   List running containers   Stop a container     docker container ls -a   docker container ls   docker stop my-container     Remove a container   Remove all stopped containers   Start a container     docker container rm my-container   docker container prune   docker start my-container     Start a container (I/O)   Inspect changes in a container   Create image from container     docker start -ai my-container   docker diff my-container   docker commit my-container new-image     Build images Docker command: docker build [OPTIONS] PATH | URL\nExample. Building an image from a Dockerfile in the current directory: docker build .\n The command assumes that a file named Dockerfile is in the current directory.  Common options:\n  Tag the image   Name of the Dockerfile       docker build -t my-image:latest .   docker build -f my-dockerfile .       Manage images   List all images   List images (no intermediate)   Remove an image     docker image ls -a   docker image ls   docker image rm my-image     Remove dangling images   Remove unused images   Show the history of an image     docker image prune   docker image prune -a   docker history my-image     Dockerfile In a Dockerfile the following main keywords are used:\n  FROM base-image   FROM scratch   RUN cmd     Specifies the base image   No base image used   Runs a command     COPY src dst   ADD src dst   WORKDIR dir     Copy source file to destination   Copy source file (including URL and TAR) to destination   Sets the working directory     ENTRYPOINT cmd   CMD params   EXPOSE port     Command to execute when container is run   Parameters of the entrypoint command   Exposes a container port     Volumes   Create a volume   Remove a volume   Remove unused volumes     docker volume create my-volume   docker volume rm my-volume   docker volume prune     List volumes         docker volume ls         Networks   Create a network   Remove a network   Remove unused networks     docker volume create my-network   docker network rm my-network   docker network prune     List all the networks   Inspect a network   Connect a container to a network     docker network ls   docker network inspect my-network   docker network connect my-network my-container     ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"251fc4af8635d45df59c44e451d80474","permalink":"/courses/cloud-computing/docker-cheat-sheet/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/docker-cheat-sheet/","section":"courses","summary":"Run containers Docker command: docker run [options] image-name [command] [arg]\nExample: Running a container from the image alpine.\n  docker run image-name   docker run image-name command   docker run image-name command arg     docker run alpine   docker run alpine ls   docker run alpine ping 192.168.3.1    Common options:\n  Remove the container when it exits   Give the container a name   Allocate a terminal for the container     docker run --rm alpine   docker run --name toto alpine   docker run -it alpine     Mount data-volume at /data**   Container port –\u0026gt; random host port   Host port 8080 –\u0026gt; container port 80     docker run -v data-volume:/data alpine   docker run --P alpine   docker run -p 8080:80 alpine     Attach container to network         docker run --network mynet alpine         Manage containers   List all containers   List running containers   Stop a container     docker container ls -a   docker container ls   docker stop my-container     Remove a container   Remove all stopped containers   Start a container     docker container rm my-container   docker container prune   docker start my-container     Start a container (I/O)   Inspect changes in a container   Create image from container     docker start -ai my-container   docker diff my-container   docker commit my-container new-image     Build images Docker command: docker build [OPTIONS] PATH | URL","tags":null,"title":"Docker Cheat Sheet","type":"docs"},{"authors":null,"categories":null,"content":"  1 Windows 1.1 Docker Desktop for Windows 1.2 Docker Toolbox for Windows  2 MacOS 2.1 Docker Desktop for Mac. 2.2 Docker Toolbox for Mac  3 Linux 4 Alternative options 4.1 Docker playground 4.2 Docker in a Linux virtual machine  5 Verify your installation 6 Interacting with Docker 6.1 Graphical interface  7 Troubleshooting   This document contains information on how to install Docker on your computer.\nAlthough you can access an online Docker environment without installing anything on your computer (see Section 4.1), you should consider this option only if you really cannot install Docker.\nThe installation procedure depends on the operating system that your computer runs.\n1 Windows The installation procedure depends on the Windows version running on your computer.\n1.1 Docker Desktop for Windows If your computer runs Windows 10 64 bits (Pro, Enterprise, or Education, build 15063 or later), you can install Docker Desktop for Windows (recommended).\n Show me more\nHardware prerequisites\n 64 bit processor.\n 4GB system RAM.\n BIOS-level hardware virtualization support must be enabled in the BIOS settings. For more information, see Virtualization.\n  VirtualBox users\nDocker for Windows uses Hyper-V as a virtual machine to run containers. Unfortunately, Hyper-V and VirtualBox are not compatible; when Hyper-V is enabled, VirtualBox will stop working.\nHowever:\n The existing VirtualBox images will not be removed.\n When you want to use VirtualBox, you can turn Hyper-V off.\n  Cannot/don’t want to install Docker Desktop for for Windows\nIf your computer doesn’t meet the hardware requirements, or you don’t want to install Docker Desktop for Windows because you don’t want to mess up your VirtualBox installation (although you shouldn’t really worry about the latter), you have two options:\n Install Docker Toolbox for Windows (Section 1.2).\n See the alternative options (Section 4).\n  Installation procedure\n Download Docker Desktop for Windows.\n Follow the installation instructions. You might need to restart the system to enable Hyper-V.\n Verify your installation (see Section 5).\n    1.2 Docker Toolbox for Windows If your computer runs Windows 7 or higher, and doesn’t meet the hardware requirements for Docker for Windows, you can install Docker Toolbox for Windows.\n Show me more\nPlease refer to these installation instructions.\nCannot install Docker Toolbox\n See the alternative options (Section 4).     2 MacOS The installation procedure depends on the version of MacOS running on your computer.\n2.1 Docker Desktop for Mac. If your computer runs MacOS 10.13 or higher, you can install Docker Desktop for Mac (recommended).\n Show me more\nHardware requirements\n Your computer hardware must be a 2010 or a newer model. Verify that your computer is compatible with Docker Desktop for Mac:  Open a terminal. Run the following command: sysctl kern.hv_support. If the output of the command is kern.hv_support: 1 your computer is compatible.  At least 4GB of RAM.  VirtualBox users\nIf you have a version of VirtualBox older than 4.3.30, you should consider upgrading it, as it would not be compatible with Docker Desktop.\nCannot install Docker Desktop for Mac\nIf your computer doesn’t meet the hardware requirements, you have two options:\n Install Docker Toolbox for Mac (Section 2.2).\n See the alternative options (Section 4).\n  Installation instructions\n Download Docker Desktop for Mac.\n Follow the installation instructions.\n Verify your installation (see Section 5).\n    2.2 Docker Toolbox for Mac If your computer runs MacOs 10.8 or higher, and doesn’t meet the hardware requirements for Docker Desktop for Mac, you can install Docker Toolbox for Mac.\n Show me more\nPlease refer to these installation instructions.\nCannot install Docker Toolbox\n See the alternative options (Section 4).     3 Linux You can install Docker on the following Linux distributions:\n CentOS (installation instructions).\n Debian (installation instructions).\n Fedora (installation instructions).\n Ubuntu (installation instructions).\n   4 Alternative options If you’re unable to install Docker on your computer, you have two options left: using the Docker playground or installing Docker in a Linux virtual machine.\n4.1 Docker playground The Docker playground is an online Docker environment that you can play with for free.\n The advantage is that you don’t have anything to install on your computer.\n The disadvantage is that you might be unable to open a session depending on the number of active sessions.\n  In order to connect to the playground, you need to create an account on DockerHub.\n 4.2 Docker in a Linux virtual machine  Install VirtualBox on your computer.\n Download the ISO image of Ubuntu Desktop.\n Open VirtualBox and select New to install a new operating system.\n Choose Linux as the operating system type and Ubuntu (64-bit) as the version.\n Set the memory size (1024 MB or higher).\n Create a virtual hard disk with the recommended size.\n Select VDI (VirtualBox Disk Image) as the hard disk type.\n Select the option Fixed size and create the new virtual machine.\n Double-click on the new virtual machine and, when prompted, select the ISO image of Ubuntu.\n Follow the instructions to install Ubuntu.\n When Ubuntu is finally installed, follow the instructions in Section 3 to install Docker in Ubuntu.\n    5 Verify your installation Open a terminal and type the following command:\ndocker run hello-world If everything is OK, you should see the output in the following figure.\n 6 Interacting with Docker In this course, we’ll learn how to interact with the Docker engine by using the command-line terminal. This option might seem a bit tedious (nobody likes to remember textual commands), but it offers a great flexibility.\nThis is the option that we recommend and for which we’ll provide a full support throughout the course.\n6.1 Graphical interface If you really want to use a graphical interface, you might want to look at Portainer, which is itself run as a Docker container.\n Linux or MacOS users\nOpen a terminal and copy and paste the following commands:\ndocker volume create portainer_data docker run -d -p 8000:8000 -p 9000:9000 --name=portainer --restart=always -v /var/run/docker.sock:/var/run/docker.sock -v portainer_data:/data portainer/portainer   Windows users Open a terminal and copy and paste the following commands:\ndocker volume create portainer_data docker run -d -p 8000:8000 -p 9000:9000 --name portainer --restart always -v \\\\.\\pipe\\docker_engine:\\\\.\\pipe\\docker_engine -v portainer_data:C:\\data portainer/portainer   When the container is up and running, the interface is available at the following URL: http://localhost:9000.\n Choose a password and create the user admin.\n Select Local to manage the Docker environment installed on your computer and click on Connect.\n Click on the endpoint Local (figure below) to access the dashboard.\n   The menu on the left of the dashboard allows you to manage the different components of your Docker environment (e.g., containers, images, volumes and networks).  A user guide of Portainer is very much out of the scope of this course. However, the interface is rather intuitive and you should easily find out how to create, run, stop and remove containers, build images and create volumes and networks.\n  7 Troubleshooting In this section we’ll document the installation issues that you might experience.\nDon’t hesitate to contact us to report your installation problems.\n ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"6c594ae3dc93f0fd803040ec37231e66","permalink":"/courses/cloud-computing/installing-docker/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/installing-docker/","section":"courses","summary":"Docker installation instructions","tags":null,"title":"Installing Docker","type":"docs"},{"authors":null,"categories":null,"content":" In this tutorial you’ll learn:\n How to run containers. How to define and build images. How to create and use volumes. How to define and use networks.  Prerequisites:\n Having installed Docker on your computer. See the installation guide. Being familiar with the notions of containers, images, volumes and networks in Docker. See the Docker primer for an introduction. Being familiar with the basic notions of Linux.  Terminology\n You’ll use the terminal to run Docker commands. Referring to the Docker architecture, the terminal is the client that communicates with the Docker daemon.\n Docker runs containers on your computer. We’ll refer to your computer as the host, the containers being the guests.\n   A containerized application is an application running in a container.    1 Running containers The command used to run a container is docker run followed by four parameters:\ndocker run [options] image-name [command] [arg] The four parameters are:\n options. List of options. image-name. The fully qualified name of the image used to run the container. command. The command to be executed in the container. arg. The arguments taken by the command executed in the container.  Only the parameter image-name is mandatory. The fuly qualified name of an image is specified as a sequence of four fields, formatted as follows:\nregistry_url/user/name:tag where:\n registry_url (optional). The URL of the registry that provides the image. If its value is not specified, the image will be looked up for in the DockerHub registry. user. The identifier of the user or organization that created the image. name (mandatory). The name of the image. tag (optional). It specifies the version of the image. If its value is not specified, the tag latest is taken, pointing to the latest version of the image.  Exercise\nExercise 1.1  For each of the following images, specify the name of the registry, the user, the name and the tag.\nregistry.redhat.io/rhel8/mysql-80\n alpine:3.11\n  alpine     Exercise\nExercise 1.2 What’s the difference between the following image names?\nalpine:latest\n registry.hub.docker.com/library/alpine\n  alpine     We now learn how to use the command docker run and some of its options. In the following exercises, we’ll run containers from the image named alpine that is available on the DockerHub registry. This image provides a lightweight distribution (i.e., it doesn’t contain many features) of Linux.\nExercise\nExercise 1.3 You want to run the container from the latest version of the image alpine. Which command would you write in the terminal?   Exercise\nExercise 1.4 Execute the command that you proposed in the previous exercise, observe the output in the terminal and explain the actions taken by Docker to run the container.   Okay but where’s the result of running the container?\nFirst of all, let’s see if the container is still running in the first place. In order to list all containers still running on the host, type the following command:\ndocker container ls  Your container shouldn’t appear in the output of the command. This is because it’s not running. In order to see all containers, including those that are not running, type the following command:\ndocker container ls -a Exercise\nExercise 1.5 What information is displayed for each container?   Exercise\nExercise 1.6 By looking at the command executed within the container (/bin/sh), can you tell why the container stopped without giving any output?   We’re now going to do something useful with the image alpine. But first, we start with some good practices that you should adopt while playing with images and containers.\n1.1 Good practices Name your containers. Although Docker assigns a default name to a new container, it’s usually a good practice to give a container a name of your choice to make it easily distinguishable. You can do it by using the option --name. Try the following:  docker run --name my-alpine alpine As before, the container stops immediately. If you list all your containers by typing again:\ndocker container ls -a you should see a container named my-alpine.\nRemove a container when it stops. Unless you want to reuse your container later, you can ask Docker to automatically remove it when it stops by using the option --rm. This will prevent unused containers from taking up too much disk space.  Try the following:\ndocker run --rm --name container-to-remove alpine If you list all the containers you should see that there is no container named container-to-remove.\nRemove unused containers. Stopped containers that have been run without using the option --rm are still stored in the host. If you want to remove a specific container (e.g., my-alpine), use the following command:  docker container rm my-alpine If you want to remove all stopped containers, use the following command:\ndocker container prune Remove unused images. Images can take up a lot of disk space. As a result, you should remember to remove those that you don’t intend to use any longer. The commands to remove a specific image and prune unused ones are docker image rm and docker image prune -a respectively.   1.2 Execute a command within a container Remember that the template of docker run is the following:\ndocker run [options] image-name [command] [arg] The optional parameter command refers to a command to be executed within the container, possibly with some arguments (parameter arg). As we saw before, when we run a container from the image alpine, a Linux terminal /bin/sh is launched.\nNotice\nThe Linux terminal /bin/sh is run within the container. Henceforth, we’ll use the following terms:\n Host terminal. The terminal that you use to interact with the operating system of your computer.   Guest terminal. The terminal that is run within the container.    By using the optional parameter command, we can run a command in the guest terminal.\nExercise\nExercise 1.7  Run a container from the image alpine and execute the Linux command ls that lists the content of the current directory.\n Where are the listed files stored? In the host or in the container?     Notice\nIn Exercise 1.7 the command ls is executed in the guest terminal, but its output is redirected to the host terminal.\nIn other words, when we run the container, we don’t interact directly with the guest terminal; we just send a command and the output is redirected to the host terminal.\n Now let’s see how to execute a command in the guest terminal that also requires an argument.\nExercise\nExercise 1.8 By using the Linux utility ping, check whether the Web site www.centralesupelec.fr is reachable.     1.3 Interacting with a container An application running in a container might need to interact with the user. For instance, the Linux command rev reverses whatever the user types on the keyboard. In order to interact with a container, you should use the option -it of docker run.\nExercise\nExercise 1.9 Run a container from the image alpine to execute the Linux command rev and interact with it.   Now run the following command:\ndocker run --name my-alpine -it alpine Note: we didn’t use the option --rm (the container will not be removed when we stop it, we’re going to use it again). Moreover, we didn’t specify any command to run in the guest terminal.\nExercise\nExercise 1.10 What do you obtain?    1.4 Starting and stopping containers. docker run is a shorthand for two Docker commands, namely docker create, that creates a container from an image, and docker start, that starts the container after its creation.\nSuppose now that you want to download a Web page by using Linux Alpine. You can use the Linux command wget followed by the URL of the page that you want to download.\nExercise\nExercise 1.11 By using the guest terminal in the container my-alpine, download this Web page.\n Where will the Web page be saved? The host computer or the container?     In my-alpine guest terminal type exit. This closes the guest terminal and, as a result, stops the container.\nNOTICE\nStopping the container will not erase any of the files stored in the container. Removing the container will.\n If you want to start the container my-alpine again, you can use the following command:\ndocker container start -ai my-alpine This will open the guest terminal of the container again; type ls to verify that the Web page that you downloaded before is still there.\n 1.5 A simple use case Suppose that you need to download all the figures of this Web page. The Linux utility wget comes in handy. However, you don’t have Linux and you’d like to avoid the hassle of installing it on your computer, or in a virtual machine, just for this task.\nA great alternative is to run Linux in a Docker container. Unfortunately, the Alpine distribution that we’ve been playing with doesn’t provide an implementation of wget with all the options that we need.\nWe turn to another Linux distribution, Ubuntu, for which DockerHub has several images.\nExercise\nExercise 1.12 Run a container with Ubuntu 19.10 and open a guest terminal. Call the container dl-figures, and avoid the option --rm, we’ll use this container later.   From now on, we’ll be interacting with the guest Ubuntu terminal. If you type the command wget, you’ll get an error (bash: wget: command not found).\nNotice\nThe image Ubuntu doesn’t include all the commands that you’d find in a full-blown Ubuntu distribution; the reason is to keep the size of the image small, a necessary constraint given that images are transferred over the Internet.\n Luckily, there’s a way to install wget in our Ubuntu distribution. Ubuntu provides a powerful command-line package manager called Advanced Package Tool (APT). First, you need to run the following command:\napt-get update which fetches the available packages from a list of sources available in file /etc/apt/sources.list.\nThen, you can install wget by running the following command:\napt-get install -y wget In order to obtain all the figures from a Web page, type the following command:\nwget -nd -H -p -P /my-figures -A jpg,jpeg,png,gif -e robots=off -w 0.5 https://www.centralesupelec.fr/fr/presentation You should see in the current directory a new folder named my-figures containing the downloaded figures; verify it by typing ls my-figures.\nBefore terminating, don’t forget to read your fortune cookie. In the shell, run the following command:\napt-get install -y fortune and then:\n/usr/games/fortune -s When you’re done, you can simply type the command exit to quit the guest terminal and stop the container.\nNotice\nYou might wonder how you can transfer the downloaded figures from the container to the host computer. We’ll see that later when we introduce the notion of volumes.\n   2 Creating Images A Docker image can be thought of as a template to create and run a container. An image is a file that contains a layered filesystem with each layer being immutable; this means that the files that belong to a layer cannot be modified or deleted, nor can files be added to a layer.\nWhen a container is created from an image, it will be composed of all the image read-only layers and, on top of them, a writable layer (termed the container layer), where all the new files created in the container will be written. For example, the figures that we downloaded in the container dl-figures were stored in the writable layer of that container.\n2.1 Interactive image creation When we run the container dl-figures in Section 1.5, we modified the container to install the command wget. You can see the modifications by typing the following command:\ndocker diff dl-figures The output consists of a list of files tagged with the letter A, C or D, indicating respectively that the file has been added (A), changed (C) or deleted (D). In this list you’ll find the downloaded figures, as well as other files that have been added or modified or deleted when we installed wget.\nExercise\nExercise 2.1 If layers, except the top one, are immutable, how can files that belong to the lower layers be modified or deleted?   We can create a new image from the container dl-figures, one that provides a Ubuntu distribution with the command wget already installed, with the following command:\ndocker commit dl-figures ubuntu-with-wget The command creates a new image called ubuntu-with-wget.\nExercise\nExercise 2.2 Run a container from the image ubuntu-with-wget and verify that the command wget is actually installed.    2.2 Dockerfiles The most common way to create an image is to use a Dockerfile, a text file that contains all the instructions necessary to build the image. The advantage of the Dockerfile is that it can be interpreted by the Docker engine, which makes the creation of images an automated and repeatable task, rather than manual like the interactive method.\nInspired by the previous example, suppose that we want to create a containerized application to download figures from a Web page. As a template for this application, we need to build a new image, that we’ll call fig-downloader.\nThe Dockerfile containing the instructions to build the image fig-downloader is as follows:\nFROM ubuntu:eoan RUN apt-get update RUN apt-get install -y wget RUN mkdir -p /my-figures WORKDIR /my-figures ENTRYPOINT [\u0026quot;wget\u0026quot;, \u0026quot;-nd\u0026quot;, \u0026quot;-r\u0026quot;, \u0026quot;-A\u0026quot;, \u0026quot;jpg,jpeg,bmp,png,gif\u0026quot;] CMD [\u0026quot;https://www.centralesupelec.fr/fr/presentation\u0026quot;] Here’s the explanation:\nWe use the image ubuntu:eoan as the base image. This corresponds to the instruction FROM ubuntu:eoan.\n We install the utility wget in the base image. This corresponds to the instructions RUN apt-get update and RUN apt-get install -y wget.\n We create a directory my-figures under the root directory of the image. This corresponds to the instruction RUN mkdir -p /my-figures.\n We set the newly created directory /my-figures as the working directory of the image. This corresponds to the instruction WORKDIR /my-figures.\n We specify the command to be executed when a container is run from this image. This corresponds to the instruction ENTRYPOINT [\u0026quot;wget\u0026quot;, \u0026quot;-nd\u0026quot;, \u0026quot;-r\u0026quot;, \u0026quot;-A\u0026quot;, \u0026quot;jpg,jpeg,bmp,png,gif\u0026quot;]. This instruction means: execute wget with the options -nd, -r, -A; the last option takes a list of file extensions (jpg,jpeg,bmp,png,gif) as its argument.\n Remember that the utility wget takes the URL of the Web page as an argument. The URL will be specified when we run the container from the image fig-downloader. Optionally, we can specify a default argument by using the keyword CMD. The meaning of the instruction CMD [\u0026quot;https://www.centralesupelec.fr/fr/presentation\u0026quot;] is: if we don’t give any URL when we run the container, the figures will be downloaded from https://www.centralesupelec.fr/fr/presentation.\n  Exercise\nExercise 2.3 What is the relation between the Dockerfile lines and the image layers?   Exercise\nExercise 2.4 Could you identify a problem in this Dockerfile? Modify the Dockerfile accordingly.    2.3 Building an image We’re now going to build an image from a Dockerfile.\nCreate a directory named fig-downloader in your computer with a file named Dockerfile inside.\n In the Dockerfile write the set of instructions that you proposed in Exercise 2.4.\n In the terminal, set the working directory to fig-downloader.\n Build an image called fig-downloader by executing the following command:\n  docker build -t fig-downloader . The . at the end of the command means that the Docker engine will look for a file named Dockerfile in the working directory.\nExercise\nExercise 2.5 Once the image is built, type the command docker image ls -a. What are the images with repository and tag \u0026lt;none\u0026gt;? Why are there three of such images?    Good to know\nIf you give the Dockerfile a different name (say, Dockerfile-fig-downloader), the command to build the image will be:\ndocker build -t fig-downloader -f Dockerfile-fig-downloader . The option -f is used to specify the name of the Dockerfile.\n Let’s dive deeper into the anatomy of an image.\nExercise\nExercise 2.6 Run the following command:\ndocker history fig-downloader\nand analyze the layers of the new image.\n Why do some layers have an ID, while other are marked as missing?   Can you find the identifiers of the intermediate images?     Exercise\nExercise 2.7 Run the following command:\ndocker run --name dl-1 fig-downloader\nWhat does it do? Where are the downloaded pictures?   Exercise\nExercise 2.8 Run the following command:\ndocker run --name dl-2 fig-downloader https://www.centralesupelec.fr/fr/nos-campus What does it do? Where are the downloaded pictures?    2.4 Containerized Python application Download this archive file and unzip it into your working directory. In this archive you’ll find:\n A Dockerfile. A Python script main.py that asks the user to enter the URL and the language of a Web page, and prints the 10 most frequent words occurring in that page. A file requirements.txt with the list of the Python packages needed to run the given script.  The content of the Dockerfile is as follows:\nFROM python:3.7-slim RUN mkdir -p /app WORKDIR /app COPY ./main.py ./requirements.txt /app/ RUN pip install -r requirements.txt ENTRYPOINT [\u0026quot;python\u0026quot;, \u0026quot;main.py\u0026quot;] Exercise\nExercise 2.9 Describe what this Dockerfile does.   Exercise\nExercise 2.10 Build an image called wordfreq from this Dockerfile.   Exercise\nExercise 2.11 Without changing the Dockerfile, rebuild the same image. What do you notice?   Exercise\nExercise 2.12 What happens if you modify a line in the Python script and you rebuild the image? Is the build cache still used?   Exercise\nExercise 2.13 Considering how the build cache is used in Docker, can you tell what’s wrong with this Dockerfile? Modify the Dockerfile accordingly.   Exercise\nExercise 2.14 Modify main.py and rebuild the image. What changed?     3 Data Volumes In Exercise 2.7 you’be been asked to run a container named dl-1 to download some figures from a Web page. The figures were downloaded into the directory /my-figures of the container. But we left a question unanswered.\nHow do we transfer those figures from the container to the host computer?\nOne way to go about that is to run the following command in the host terminal:\ndocker cp dl-1:/my-figures . This will copy the directory /my-figures from the container dl-1 to the host computer working directory. You can verify it by yourself.\nExercise\nExercise 3.1 Can you tell why this solution is less than ideal?   3.1 Using a host volume A better solution is to mount (i.e., attach) a directory of the host computer at the container’s directory /my-figures when we run it. Let’s see how it works.\nStep 1. Create a directory named figs-volume in your working directory.\nStep 2. Type and execute the following command:\ndocker run --rm -v $(pwd)/figs-volume:/my-figures fig-downloader This command runs a container from the image fig-downloader.\n With the option -v we specify that we want to mount the directory $(pwd)/figs-volume ($(pwd) indicates the host working directory) at the directory figs-volume in the container;\n The option --rm indicates that we want the container to be removed when its execution is over.\n  Step 3. Verify that the pictures are in the folder figs-volume.\nIn this example, we’ve used the directory figs-volume as a volume (essentially, an external storage area) of the container; when the container is destroyed, the volume remains with all its data.\n 3.2 Docker volumes In the example that we’ve just described, we’ve used a host directory as a volume. This is useful when we, or an application running on the host, need to access the files produced by a container. In all the other cases, a container should use a Docker volume, which is managed directly by the Docker engine.\nLet’s create a new Docker volume called data-volume:\ndocker volume create data-volume Good to know (advanced notion)\nWhere the data will be actually stored?\nYou can inspect the new volume by typing the following command (or, you can click on the volume in the GUI):\ndocker volume inspect data-volume A mount path is indicated; that’s the folder where the data will be actually stored. If your computer runs Linux, that folder will be available on the host; if your computer runs Windows or MacOS, you’ll not find that folder on your computer. Instead, it will be available in the hidden virtual machine that Docker for Windows and Docker for Mac use.\nDo you want to see the directory?\nOne way to look into the hidden VM is to run the following containerized application:\ndocker run -it --rm --privileged --pid=host justincormack/nsenter1 This application will open a guest terminal into the VM. You can then use the commands cd and ls to browse to the directory indicated as the mount path of the new volume.\n 3.2.1 Sharing data A Docker volume can be used to share data between containers.\nExercise\nExercise 3.2 Run a container from the image ubuntu:eoan, specifying the options to:\n Remove the container once its execution is over.\n Interact with the terminal in the container.\n   Mount the volume data-volume at the container’s directory /data.     Exercise\nExercise 3.3 Type a command in the guest Linux terminal to create a file test-file.txt in the directory /data. Verify that the file is created.   Exercise\nExercise 3.4 Run a container from the image alpine:latest, specifying the options to:\n Remove the container once its execution is over.\n Interact with the terminal in the container.\n   Mount the volume data-volume to the directory /my-data of the container.     Exercise\nExercise 3.5 Verify that you can read the file test-file.txt. Which folder would you look in?   In the guest terminals of both containers type exit. This will terminate and destroy (since we used the option --rm) the containers.\nExercise\nExercise 3.6 Will the file test-file.txt be removed? Why?      4 Single-Host Networking In order to let containers communicate and, therefore, co-operate, Docker defines a simple networking model known as the container network model\nExercise\nExercise 4.1 Describe the output of the following command:\ndocker network ls\n  Exercise\nExercise 4.2 The following command:\ndocker network inspect bridge\noutputs the configuration of the network bridge. By looking at this configuration, can you tell what IP addresses will be given to the containers attached to this network? What’s the IP address of the router of this network?   4.1 Creating networks By default, any new container is attached to the network named bridge. As a result, all new containers will be able to communicate over this network. This is not a good idea. If a hacker can compromise any of these containers, s/he might be able to attack the other containers as well. As a rule of thumb, we should attach two containers to the same network only on a need-to-communicate basis.\nExercise 4.3 What if a container doesn’t need to use the network at all? Try to run a container disconnected from any network and verify that you cannot ping the URL www.google.com.   In order to create a new network, you can use the following command:\ndocker network create network_name Exercise\nExercise 4.4 Create two networks named buckingham and rochefort that use the driver bridge. By using the docker network inspect command, look at the IP addresses of the new networks and write them down.   Exercise\nExercise 4.5 Create three containers athos, porthos and aramis and attach them to the two networks buckingham and rochefort as displayed in this figure. The three containers will open a Linux Alpine shell. You’ll need to launch the commands in three separate tabs of your terminal window.\n What will the IP addresses of the three containers be in the two networks? Remember that porthos is attached to two networks, therefore it’ll have two network interfaces (endpoints) and, as a result, two IP addresses.   Verify your answers by inspecting the two networks (use the command docker network inspect).      4.2 Communication between containers Let’s see if and when the three containers can communicate.\nExercise\nExercise 4.6 Which containers are able to communicate? Justify your answer.   Exercise\nExercise 4.7 Try to ping porthos from athos by using its IP address.\n Which IP address of porthos would you use?     Exercise\nExercise 4.8 Try to ping porthos from athos by using its name. Do you succeed? Are you surprised?    4.3 A containerized chat room We developed a simple chat room in Python that you can download here.\nParticipants use a client program to connect to the chat room; the chat room is managed by a server application that receives the client connections and forwards the messages between the users. The archive contains the following files:\n client.py. Implementation of the chat room client-side. server.py. Implementation of the chat room server-side. utils.py. Library with utility functions used in both client.py and server.py.  Exercise\nExercise 4.9 By using Dockerfiles, create two images chat-client and chat-server that will be used to run the client and the server in Docker.   We’ll now run both containers. Since they need to communicate, they need to be attached to the same network (e.g., buckingham).\nExercise\nExercise 4.10 Run a container from the image server-chat. Set the options to:\n Automatically remove the container once its execution is over.\n Give a name to the container (e.g., server-chat).\n The server will print messages on the screen. In order to see them, you must use the option -t.\n  Also, keep in mind that server.py takes an argument that is the port number where the server will listen to incoming connections.\nWhat is the IP address of the server?   Exercise\nExercise 4.11  Run a container from the image client-chat. Set the options to:\n Automatically remove the container once its execution is over.\n Give a name to the container (e.g., client-chat).\n Since you’ll use the the client to write messages in the chat room, remember to set the option -it.\n  The client takes two arguments: the host where the server is running and the port which the server is listening to.   Once the client is started, you’ll be prompted to enter your name. Then you can start writing messages.\nNotice\n You can type #quit at any moment to exit the chat room (client-side).\n Type Ctrl-C to stop the server.\n   Now, suppose that one of your classmates wants to join the chat room, but s/he’s on another computer.\nExercise\nExercise 4.12 Do you think your classmate can connect to the containerized server running in your machine? Justify your answer.   What we need to do here is to expose our server to the outside world. The server runs in a container \\(c\\) that, in turns, runs on the host machine \\(h\\). The server listens to port \\(p_c\\) that is opened inside the container. We need to map port \\(p_c\\) to a port \\(p_h\\) in the host computer. This way, the classmate client will connect to the server by specifying the IP address of the host \\(h\\) (not \\(c\\)) and \\(p_h\\) as the port number.\nWe implement this solution step by step.\nStop both the server and the client running on your machine.\n Declare the port number to expose.\n  Exercise\nExercise 4.13 How would you add this declaration? Modify the Dockerfile accordingly?   Rebuild the image server-chat.\n Run the server container so that that the exposed port is mapped to a random port in the host computer.\n  Exercise\nExercise 4.14 Which option of the command docker container run would you use? Write the command to run the container and execute it.   Verify that the exposed port \\(p_c\\) is correctly mapped to a port \\(p_h\\) in the host computer by running the following command.  docker container port chat-server Exercise\nExercise 4.15 How do you read the output of this command?   Run a client from your host computer (same as before).\n Ask any of your classmates to connect to your server. For this, you’ll need to tell your classmate the IP address of your machine and the port number \\(p_h\\).\n    ","date":-62135596800,"expirydate":-62135596800,"kind":"page","lang":"en","lastmod":-62135596800,"objectID":"b1c73741be8d194e44f9ae17ce61cc84","permalink":"/courses/cloud-computing/tutorial-docker/","publishdate":"0001-01-01T00:00:00Z","relpermalink":"/courses/cloud-computing/tutorial-docker/","section":"courses","summary":"Text of the lab assignment on Docker","tags":null,"title":"Getting started with Docker","type":"docs"}]